<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nRF54L Pin Planner</title>
    <style>
        :root {
            --primary-color: #0066cc;
            --secondary-color: #e6f2ff;
            --border-color: #cccccc;
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            --disabled-color: #f1f1f1;
            --text-color: #333333;
            --light-text: #666666;
            --system-color: #8e44ad; /* Purple color for system/required components */
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .peripheral-selector {
            flex: 1;
            min-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }

        .chip-display {
            flex: 1;
            min-width: 600px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }

        .selected-peripherals {
            flex: 1;
            min-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }
        
        .simple-peripherals {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        .required-peripherals {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--system-color);
            border-radius: 5px;
            background-color: #f8f0ff;
        }
        
        .checkbox-group {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .checkbox-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            font-weight: 500;
            cursor: pointer;
        }
        
        .checkbox-label input {
            margin-right: 8px;
        }
        
        .checkbox-description {
            margin-top: 5px;
            margin-left: 24px;
            font-size: 0.9em;
            color: var(--light-text);
        }
        
        .system-peripheral {
            font-weight: 600;
            color: var(--system-color);
        }

        .peripheral-group {
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .peripheral-item {
            cursor: pointer;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .peripheral-item:hover {
            background-color: var(--secondary-color);
        }

        .peripheral-item.disabled {
            opacity: 0.5;
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }

        .peripheral-item.selected {
            background-color: var(--primary-color);
            color: white;
        }

        .chip-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            background-color: #e0e0e0;
            border-radius: 10px;
        }

        .pin {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #cccccc;
            border: 1px solid #999999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .pin:hover {
            transform: scale(1.2);
            z-index: 100;
        }

        .pin.used {
            background-color: var(--primary-color);
            color: white;
        }

        .pin.clock {
            background-color: var(--warning-color);
        }

        .pin.required {
            background-color: var(--error-color);
            color: white;
        }

        .pin.system {
            background-color: var(--system-color);
            color: white;
        }

        .pin.vdd, .pin.vss, .pin.debug {
            background-color: #999999;
            color: white;
        }

        .pin-details {
            margin: 20px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            min-height: 100px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px; /* Set a minimum height if needed */
        }

        .selected-list {
            list-style-type: none;
            padding: 0;
        }

        .selected-item {
            background-color: var(--secondary-color);
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .selected-item.system {
            background-color: #f8f0ff;
            border-left: 3px solid var(--system-color);
        }

        .remove-btn {
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
        }

        .remove-btn:hover {
            opacity: 0.9;
        }
        
        .remove-btn.disabled {
            background-color: var(--disabled-color);
            color: var(--light-text);
            cursor: not-allowed;
        }

        .legend {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .button-group {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }

        button {
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0055aa;
        }

        button:disabled {
            background-color: var(--disabled-color);
            color: var(--light-text);
            cursor: not-allowed;
        }

        /* Pin positioning - Fixed for better alignment */
        .chip-container {
            position: relative;
            width: 420px;
            height: 420px;
            margin: 0 auto;
            background-color: #e0e0e0;
            border-radius: 10px;
        }

        .chip-body {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            width: 400px;
            height: 400px;
            background-color: #d0d0d0;
            border-radius: 5px;
        }

        .pin {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #cccccc;
            border: 1px solid #999999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        /* New CSS for vertical accordion menu */
        .accordion {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .accordion-item {
            border-bottom: 1px solid var(--border-color);
        }
        
        .accordion-item:last-child {
            border-bottom: none;
        }
        
        .accordion-header {
            background-color: #f1f1f1;
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .accordion-header:hover {
            background-color: #e0e0e0;
        }
        
        .accordion-header.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .accordion-content {
            display: none;
            padding: 15px;
            background-color: white;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .accordion-content.active {
            display: block;
        }
        
        .expand-icon {
            transition: transform 0.3s;
        }
        
        .accordion-header.active .expand-icon {
            transform: rotate(180deg);
        }
        
        /* Single-instance peripheral button */
        .single-peripheral-btn {
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 8px;
            padding: 10px 15px;
            background-color: #f1f1f1;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .single-peripheral-btn:hover {
            background-color: #e0e0e0;
        }
        
        .single-peripheral-btn.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .peripherals-section {
            margin-bottom: 20px;
        }
        
        .peripherals-heading {
            margin-bottom: 10px;
            color: var(--primary-color);
            font-size: 1rem;
            font-weight: 600;
        }

        /* Modal for pin selection */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
        }

        .pin-selection-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .pin-selection-table th, 
        .pin-selection-table td {
            padding: 10px;
            border: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
        }

        .pin-selection-table th {
            background-color: #f5f5f5;
        }

        .pin-selection-table select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .pin-selection-table .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pin-selection-table .checkbox-option {
            display: flex;
            align-items: center;
        }

        .pin-selection-table .checkbox-option input {
            margin-right: 8px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        /* Package selection dropdown */
        .package-selector {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--secondary-color);
        }
        
        .package-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>nRF54L Pin Planner</h1>
            <p>Select peripherals and visualize pin assignments for your nRF54L</p>
            <div style="background-color: #fff3cd; color: #856404; padding: 10px; border: 1px solid #ffeeba; border-radius: 5px; margin-top: 10px; font-weight: bold; text-align: center;">
                NOT an official Nordic application. Please double check all configurations with the nRF54L documentation available here: 
                <a href="https://docs.nordicsemi.com/category/nrf-54L-series" target="_blank">https://docs.nordicsemi.com/category/nrf-54L-series</a>
            </div>
        </div>
        
        <!-- Package Selection Dropdown -->
        <div class="package-selector">
            <h3>Package Selection</h3>
            <select id="packageSelector">
                <option value="QFN-48" selected>QFN-48</option>
                <option value="WLCSP" disabled>WLCSP (Coming Soon)</option>
            </select>
        </div>

        <div class="flex-container">
            <div class="peripheral-selector">
                <h2>Available Peripherals</h2>
                <input type="text" id="searchPeripherals" class="search-box" placeholder="Search peripherals...">
                
                <!-- Optional Simple Peripherals Section -->
                <div class="simple-peripherals">
                    <h3>Pin Specific Peripherals</h3>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="xl1xl2-checkbox"> 
                            <span>32.768 kHz Crystal (XL1/XL2)</span>
                        </label>
                        <div class="checkbox-description">Uses P1.00 and P1.01 for low-frequency crystal</div>
                    </div>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="nfc-checkbox"> 
                            <span>NFC Antenna (NFC1/NFC2)</span>
                        </label>
                        <div class="checkbox-description">Uses P1.02 and P1.03 for NFC antenna</div>
                    </div>
                </div>
                
                <!-- Single-instance peripherals section -->
                <div class="peripherals-section">
                    <div class="peripherals-heading">Single-Instance Peripherals</div>
                    <div id="single-peripherals-container">
                        <!-- Will be filled dynamically -->
                    </div>
                </div>
                
                <!-- Multiple-instance peripherals accordion section -->
                <div class="peripherals-section">
                    <div class="peripherals-heading">Multiple-Instance Peripherals</div>
                    <div class="accordion" id="peripheralAccordion">
                        <!-- Will be filled dynamically with multi-instance peripherals -->
                    </div>
                </div>
            </div>

            <div class="chip-display">
                <h2 id="chipTitleDisplay">QFN-48 Pin Layout</h2>
                <div class="chip-container">
                    <div class="left-pins"></div>
                    <div class="right-pins"></div>
                    <div class="top-pins"></div>
                    <div class="bottom-pins"></div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #cccccc;"></div>
                        <span>Available</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--primary-color);"></div>
                        <span>Used</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--warning-color);"></div>
                        <span>Clock Pin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--error-color);"></div>
                        <span>Required</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--system-color);"></div>
                        <span>System</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #999999;"></div>
                        <span>Power/Debug</span>
                    </div>
                </div>
                <div class="pin-details" id="pinDetails">
                    <p>Click a pin to see details...</p>
                </div>
            </div>

            <div class="selected-peripherals">
                <h2>Selected Peripherals</h2>
                <ul class="selected-list" id="selectedList">
                    <li class="empty-message">No peripherals selected yet.</li>
                </ul>
                <div class="button-group">
                    <button id="clearAllBtn">Clear All</button>
                    <button id="exportBtn">Export Configuration</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Pin Selection Modal -->
    <div id="pinSelectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Select Pins for Peripheral</h2>
                <span class="close">&times;</span>
            </div>
            <div id="modalBody">
                <p>Select which pins to use for each peripheral function:</p>
                <table class="pin-selection-table" id="pinSelectionTable">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Required</th>
                            <th>Pin Selection</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody id="pinSelectionTableBody">
                        <!-- Will be filled dynamically -->
                    </tbody>
                </table>
            </div>
            <div class="modal-footer">
                <button id="cancelPinSelection">Cancel</button>
                <button id="confirmPinSelection">Confirm Selection</button>
            </div>
        </div>
    </div>
    
    <script>
        // Data structures
        const peripherals = {
            "SPI": [
                { id: "SPIM/SPIS00", port: "Port 2", pins: "Any pins", notes: "SCLK requires clock pin; 32MHz requires high drive low and high", address: "0x5004A000" },
                { id: "SPIM/SPIS20", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCLK requires clock pin", address: "0x500C6000" },
                { id: "SPIM/SPIS21", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCLK requires clock pin", address: "0x500C7000" },
                { id: "SPIM/SPIS22", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCLK requires clock pin", address: "0x500C8000" },
                { id: "SPIM/SPIS30", port: "Port 0", pins: "Any pins", notes: "SCLK requires clock pin", address: "0x50104000" }
            ],
            "TAMPC": [
                { id: "TAMPC", port: "Port 1", pins: "Specific pin pairs", notes: "Active shield pairs must be used together", address: "0x500D8000" }
            ],
            "I2C": [
                { id: "TWIM/TWIS20", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCL requires clock pin", address: "0x500C6000" },
                { id: "TWIM/TWIS21", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCL requires clock pin", address: "0x500C7000" },
                { id: "TWIM/TWIS22", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "SCL requires clock pin", address: "0x500C8000" },
                { id: "TWIM/TWIS30", port: "Port 0", pins: "Any pins", notes: "SCL requires clock pin", address: "0x50104000" }
            ],
            "UART": [
                { id: "UARTE00", port: "Port 2", pins: "Any pins", notes: "", address: "0x5004A000" },
                { id: "UARTE20", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "", address: "0x500C6000" },
                { id: "UARTE21", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "", address: "0x500C7000" },
                { id: "UARTE22", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2)", notes: "", address: "0x500C8000" },
                { id: "UARTE30", port: "Port 0", pins: "Any pins", notes: "", address: "0x50104000" }
            ],
            "Others": [
                { id: "PDM20", port: "Port 1", pins: "Any pins", notes: "CLK requires clock pin", address: "0x500D0000" },
                { id: "PDM21", port: "Port 1", pins: "Any pins", notes: "CLK requires clock pin", address: "0x500D1000" },
                { id: "PWM20", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D2000" },
                { id: "PWM21", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D3000" },
                { id: "PWM22", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D4000" },
                { id: "I2S20", port: "Port 1", pins: "Any pins", notes: "MCK and SCK require clock pin", address: "0x500DD000" },
                // Removed NFCT from here as it's handled separately in checkboxes
                { id: "SAADC", port: "Port 1", pins: "P1.04, P1.05, P1.06, P1.07, P1.11, P1.12, P1.13, P1.14", notes: "Specific pins only", address: "0x500D5000" },
                { id: "GPIOTE20", port: "Port 1", pins: "Any pins", notes: "8 channels, applies to P1 pins only", address: "0x500DA000", channels: 8 },
                { id: "GPIOTE30", port: "Port 0", pins: "Any pins", notes: "4 channels, applies to P0 pins only", address: "0x5010C000", channels: 4 },
                { id: "GRTC", port: "Mixed", pins: "(CLKOUT32K/GRTCLFCLKOUT, P0.04), (PWMOUT/GRTCPWM, P0.03), (CLK16M, P1.08)", notes: "Specific pin assignments", address: "0x500E2000" },
                { id: "QDEC20", port: "Port 1", pins: "Any pins", notes: "", address: "0x500E0000" },
                { id: "QDEC21", port: "Port 1", pins: "Any pins", notes: "", address: "0x500E1000" }
            ],
            "RADIO": [
                { id: "RADIO", port: "Port 1", pins: "P1.05, P1.09, P1.10, P1.11, P1.12, P1.13, P1.14", notes: "Direction Finding pins for Bluetooth", address: "0x50010000" }
            ],
            "TRACE": [
                { id: "TRACE", port: "Port 2", pins: "P2.06, P2.07, P2.08, P2.09, P2.10", notes: "Debug trace interface", address: "0x50008000" }
            ]
        };

        // Pin data: number, pin name, is it a clock pin, special function
        const pinData = [
            { number: 1, name: "P1.00", isClock: false, port: "P1", index: 0, type: "io", functions: ["XL1", "Digital I/O", "Analog input"] },
            { number: 2, name: "P1.01", isClock: false, port: "P1", index: 1, type: "io", functions: ["XL2", "Digital I/O", "Analog input"] },
            { number: 3, name: "P1.02", isClock: false, port: "P1", index: 2, type: "io", functions: ["NFC1", "Digital I/O", "NFC input"] },
            { number: 4, name: "P1.03", isClock: true, port: "P1", index: 3, type: "io", functions: ["NFC2", "Digital I/O", "NFC input"] },
            { number: 5, name: "P1.04", isClock: true, port: "P1", index: 4, type: "io", functions: ["ASO[0]", "AIN0", "Digital I/O", "TAMPC active shield 0 output", "Analog input"] },
            { number: 6, name: "P1.05", isClock: false, port: "P1", index: 5, type: "io", functions: ["ASI[0]", "RADIO[6]", "AIN1", "Digital I/O", "TAMPC active shield 0 input", "Analog input"] },
            { number: 7, name: "P1.06", isClock: false, port: "P1", index: 6, type: "io", functions: ["ASO[1]", "AIN2", "Digital I/O", "TAMPC active shield 1 output", "Analog input"] },
            { number: 8, name: "P1.07", isClock: false, port: "P1", index: 7, type: "io", functions: ["ASI[1]", "AIN3", "Digital I/O", "TAMPC active shield 1 input", "Analog input"] },
            { number: 9, name: "P1.08", isClock: true, port: "P1", index: 8, type: "io", functions: ["CLK16M", "EXTREF", "Digital I/O", "GRTC HF clock output", "External reference for SAADC"] },
            { number: 10, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 11, name: "P2.00", isClock: false, port: "P2", index: 0, type: "io", functions: ["Digital I/O", "SPIM DCX", "UARTE RXD", "QSPI D3"] },
            { number: 12, name: "P2.01", isClock: true, port: "P2", index: 1, type: "io", functions: ["Digital I/O", "SPIM SCK", "SPIS SCK", "QSPI SCK"] },
            { number: 13, name: "P2.02", isClock: false, port: "P2", index: 2, type: "io", functions: ["Digital I/O", "SPIM SDO", "SPIS SDO", "UARTE TXD", "QSPI D0", "Serial wire output (SWO)"] },
            { number: 14, name: "P2.03", isClock: false, port: "P2", index: 3, type: "io", functions: ["Digital I/O", "QSPI D2"] },
            { number: 15, name: "P2.04", isClock: false, port: "P2", index: 4, type: "io", functions: ["Digital I/O", "SPIM SDI", "SPIS SDI", "UARTE CTS", "QSPI D1"] },
            { number: 16, name: "P2.05", isClock: false, port: "P2", index: 5, type: "io", functions: ["Digital I/O", "SPIM CS", "UARTE RTS", "QSPI CS"] },
            { number: 17, name: "P2.06", isClock: true, port: "P2", index: 6, type: "io", functions: ["TRACECLK", "Digital I/O", "SPIM SCK", "SPIS SCK", "Trace clock"] },
            { number: 18, name: "P2.07", isClock: false, port: "P2", index: 7, type: "io", functions: ["TRACEDATA[0]", "SWO", "Digital I/O", "Trace data", "Serial wire output (SWO)", "SPIM DCX", "UARTE RXD"] },
            { number: 19, name: "P2.08", isClock: false, port: "P2", index: 8, type: "io", functions: ["TRACEDATA[1]", "Digital I/O", "Trace data", "SPIM SDO", "SPIS SDO", "UARTE TXD"] },
            { number: 20, name: "P2.09", isClock: false, port: "P2", index: 9, type: "io", functions: ["TRACEDATA[2]", "Digital I/O", "Trace data", "SPIM SDI", "SPIS SDI", "UARTE CTS"] },
            { number: 21, name: "P2.10", isClock: false, port: "P2", index: 10, type: "io", functions: ["TRACEDATA[3]", "Digital I/O", "Trace data", "SPIM CS", "UARTE RTS"] },
            { number: 22, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 23, name: "P0.00", isClock: false, port: "P0", index: 0, type: "io", functions: ["Digital I/O"] },
            { number: 24, name: "P0.01", isClock: false, port: "P0", index: 1, type: "io", functions: ["Digital I/O"] },
            { number: 25, name: "SWDIO", isClock: false, port: null, index: null, type: "debug", functions: ["Serial wire data. Bidirectional with standard-drive and on-chip pull-down."] },
            { number: 26, name: "SWDCLK", isClock: false, port: null, index: null, type: "debug", functions: ["Serial wire clock. Input with on-chip pull-up."] },
            { number: 27, name: "P0.02", isClock: false, port: "P0", index: 2, type: "io", functions: ["Digital I/O"] },
            { number: 28, name: "P0.03", isClock: true, port: "P0", index: 3, type: "io", functions: ["GRTCPWM", "Digital I/O", "GRTC PWM output"] },
            { number: 29, name: "P0.04", isClock: true, port: "P0", index: 4, type: "io", functions: ["GRTCLFCLKOUT", "Digital I/O", "GRTC LF clock output"] },
            { number: 30, name: "nRESET", isClock: false, port: null, index: null, type: "reset", functions: ["Pin reset with on-chip pull-up"] },
            { number: 31, name: "ANT", isClock: false, port: null, index: null, type: "rf", functions: ["Single ended radio antenna connection"] },
            { number: 32, name: "VSS_PA", isClock: false, port: null, index: null, type: "vss", functions: ["Ground (radio supply)"] },
            { number: 33, name: "DECRF", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 34, name: "XC1", isClock: false, port: null, index: null, type: "crystal", functions: ["Connection for 32 MHz crystal"] },
            { number: 35, name: "XC2", isClock: false, port: null, index: null, type: "crystal", functions: ["Connection for 32 MHz crystal"] },
            { number: 36, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 37, name: "P1.09", isClock: false, port: "P1", index: 9, type: "io", functions: ["ASO[2]", "RADIO[0]", "Digital I/O", "TAMPC active shield 2 output", "RADIO DFEGPIO"] },
            { number: 38, name: "P1.10", isClock: false, port: "P1", index: 10, type: "io", functions: ["ASI[2]", "RADIO[1]", "Digital I/O", "TAMPC active shield 2 input", "RADIO DFEGPIO"] },
            { number: 39, name: "P1.11", isClock: true, port: "P1", index: 11, type: "io", functions: ["ASO[3]", "RADIO[2]", "AIN4", "Digital I/O", "TAMPC active shield 3 output", "RADIO DFEGPIO", "Analog input"] },
            { number: 40, name: "P1.12", isClock: true, port: "P1", index: 12, type: "io", functions: ["ASI[3]", "RADIO[3]", "AIN5", "Digital I/O", "TAMPC active shield 3 input", "RADIO DFEGPIO", "Analog input"] },
            { number: 41, name: "P1.13", isClock: false, port: "P1", index: 13, type: "io", functions: ["RADIO[4]", "AIN6", "Digital I/O", "RADIO DFEGPIO", "Analog input"] },
            { number: 42, name: "P1.14", isClock: false, port: "P1", index: 14, type: "io", functions: ["RADIO[5]", "AIN7", "Digital I/O", "RADIO DFEGPIO", "Analog input"] },
            { number: 43, name: "DECA", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 44, name: "VSS", isClock: false, port: null, index: null, type: "vss", functions: ["Ground"] },
            { number: 45, name: "DECD", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 46, name: "DCC", isClock: false, port: null, index: null, type: "power", functions: ["DC/DC regulator output"] },
            { number: 47, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 48, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] }
        ];

        // Define peripheral functions required for each peripheral type
        const peripheralFunctions = {
            "SPI": [
                { name: "SPIM SCK", description: "SPI Clock", required: true, requiresClock: true },
                { name: "SPIM SDO", description: "SPI MOSI (Master Out, Slave In)", required: true, requiresClock: false },
                { name: "SPIM SDI", description: "SPI MISO (Master In, Slave Out)", required: true, requiresClock: false },
                { name: "SPIM CS", description: "SPI Chip Select", required: true, requiresClock: false },
                { name: "SPIM DCX", description: "SPI Data/Command", required: false, requiresClock: false }
            ],
            "TAMPC": [
                { name: "Shield Pair 0", description: "Active Shield 0 (ASO[0]/ASI[0])", required: false, isPair: true, 
                  outputPin: "P1.04", inputPin: "P1.05", outputFunc: "ASO[0]", inputFunc: "ASI[0]" },
                { name: "Shield Pair 1", description: "Active Shield 1 (ASO[1]/ASI[1])", required: false, isPair: true, 
                  outputPin: "P1.06", inputPin: "P1.07", outputFunc: "ASO[1]", inputFunc: "ASI[1]" },
                { name: "Shield Pair 2", description: "Active Shield 2 (ASO[2]/ASI[2])", required: false, isPair: true, 
                  outputPin: "P1.09", inputPin: "P1.10", outputFunc: "ASO[2]", inputFunc: "ASI[2]" },
                { name: "Shield Pair 3", description: "Active Shield 3 (ASO[3]/ASI[3])", required: false, isPair: true, 
                  outputPin: "P1.11", inputPin: "P1.12", outputFunc: "ASO[3]", inputFunc: "ASI[3]" }
            ],
            "I2C": [
                { name: "TWIM SCL", description: "I2C Serial Clock Line", required: true, requiresClock: true },
                { name: "TWIM SDA", description: "I2C Serial Data Line", required: true, requiresClock: false }
            ],
            "UART": [
                { name: "UARTE TXD", description: "UART Transmit Data", required: true, requiresClock: false },
                { name: "UARTE RXD", description: "UART Receive Data", required: true, requiresClock: false },
                { name: "UARTE CTS", description: "UART Clear To Send", required: false, requiresClock: false },
                { name: "UARTE RTS", description: "UART Request To Send", required: false, requiresClock: false }
            ],
            "PDM": [
                { name: "PDM CLK", description: "PDM Clock", required: true, requiresClock: true },
                { name: "PDM DIN", description: "PDM Data In", required: true, requiresClock: false }
            ],
            "PWM": [
                { name: "PWM OUT0", description: "PWM Output 0", required: true, requiresClock: false },
                { name: "PWM OUT1", description: "PWM Output 1", required: false, requiresClock: false },
                { name: "PWM OUT2", description: "PWM Output 2", required: false, requiresClock: false },
                { name: "PWM OUT3", description: "PWM Output 3", required: false, requiresClock: false }
            ],
            "I2S": [
                { name: "I2S SCK", description: "I2S Serial Clock", required: true, requiresClock: true },
                { name: "I2S LRCK", description: "I2S Left/Right Clock", required: true, requiresClock: false },
                { name: "I2S SDIN", description: "I2S Serial Data In", required: true, requiresClock: false },
                { name: "I2S SDOUT", description: "I2S Serial Data Out", required: false, requiresClock: false },
                { name: "I2S MCK", description: "I2S Master Clock", required: false, requiresClock: true }
            ],
            "QDEC": [
                { name: "QDEC A", description: "Quadrature Decoder A Input", required: true, requiresClock: false },
                { name: "QDEC B", description: "Quadrature Decoder B Input", required: true, requiresClock: false },
                { name: "QDEC LED", description: "Quadrature Decoder LED Output", required: false, requiresClock: false }
            ],
            "NFCT": [
                { name: "NFC1", description: "NFC Pin 1", required: true, requiresClock: false, specificPin: "P1.02" },
                { name: "NFC2", description: "NFC Pin 2", required: true, requiresClock: false, specificPin: "P1.03" }
            ],
            "SAADC": [
                { name: "AIN0", description: "Analog Input 0", required: false, requiresClock: false, specificPin: "P1.04" },
                { name: "AIN1", description: "Analog Input 1", required: false, requiresClock: false, specificPin: "P1.05" },
                { name: "AIN2", description: "Analog Input 2", required: false, requiresClock: false, specificPin: "P1.06" },
                { name: "AIN3", description: "Analog Input 3", required: false, requiresClock: false, specificPin: "P1.07" },
                { name: "AIN4", description: "Analog Input 4", required: false, requiresClock: false, specificPin: "P1.11" },
                { name: "AIN5", description: "Analog Input 5", required: false, requiresClock: false, specificPin: "P1.12" },
                { name: "AIN6", description: "Analog Input 6", required: false, requiresClock: false, specificPin: "P1.13" },
                { name: "AIN7", description: "Analog Input 7", required: false, requiresClock: false, specificPin: "P1.14" }
            ],
            "GRTC": [
                { name: "GRTCPWM", description: "GRTC PWM Output", required: false, requiresClock: false, specificPin: "P0.03" },
                { name: "GRTCLFCLKOUT", description: "GRTC LF Clock Output", required: false, requiresClock: true, specificPin: "P0.04" },
                { name: "CLK16M", description: "GRTC HF Clock Output", required: false, requiresClock: true, specificPin: "P1.08" }
            ],
            // Updated GPIOTE functions to support multiple channels
            "GPIOTE20": [
                { name: "GPIOTE PIN-0", description: "GPIOTE Channel 0", required: false, requiresClock: false, channel: 0 },
                { name: "GPIOTE PIN-1", description: "GPIOTE Channel 1", required: false, requiresClock: false, channel: 1 },
                { name: "GPIOTE PIN-2", description: "GPIOTE Channel 2", required: false, requiresClock: false, channel: 2 },
                { name: "GPIOTE PIN-3", description: "GPIOTE Channel 3", required: false, requiresClock: false, channel: 3 },
                { name: "GPIOTE PIN-4", description: "GPIOTE Channel 4", required: false, requiresClock: false, channel: 4 },
                { name: "GPIOTE PIN-5", description: "GPIOTE Channel 5", required: false, requiresClock: false, channel: 5 },
                { name: "GPIOTE PIN-6", description: "GPIOTE Channel 6", required: false, requiresClock: false, channel: 6 },
                { name: "GPIOTE PIN-7", description: "GPIOTE Channel 7", required: false, requiresClock: false, channel: 7 }
            ],
            "GPIOTE30": [
                { name: "GPIOTE PIN-0", description: "GPIOTE Channel 0", required: false, requiresClock: false, channel: 0 },
                { name: "GPIOTE PIN-1", description: "GPIOTE Channel 1", required: false, requiresClock: false, channel: 1 },
                { name: "GPIOTE PIN-2", description: "GPIOTE Channel 2", required: false, requiresClock: false, channel: 2 },
                { name: "GPIOTE PIN-3", description: "GPIOTE Channel 3", required: false, requiresClock: false, channel: 3 }
            ],
            "RADIO": [
                { name: "RADIO[0]", description: "Direction Finding GPIO 0", required: false, requiresClock: false, specificPin: "P1.09" },
                { name: "RADIO[1]", description: "Direction Finding GPIO 1", required: false, requiresClock: false, specificPin: "P1.10" },
                { name: "RADIO[2]", description: "Direction Finding GPIO 2", required: false, requiresClock: false, specificPin: "P1.11" },
                { name: "RADIO[3]", description: "Direction Finding GPIO 3", required: false, requiresClock: false, specificPin: "P1.12" },
                { name: "RADIO[4]", description: "Direction Finding GPIO 4", required: false, requiresClock: false, specificPin: "P1.13" },
                { name: "RADIO[5]", description: "Direction Finding GPIO 5", required: false, requiresClock: false, specificPin: "P1.14" },
                { name: "RADIO[6]", description: "Direction Finding GPIO 6", required: false, requiresClock: false, specificPin: "P1.05" }
            ],
            "TRACE": [
                { name: "TRACECLK", description: "Trace Clock", required: true, requiresClock: true, specificPin: "P2.06" },
                { name: "TRACEDATA[0]", description: "Trace Data 0", required: true, requiresClock: false, specificPin: "P2.07" },
                { name: "TRACEDATA[1]", description: "Trace Data 1", required: false, requiresClock: false, specificPin: "P2.08" },
                { name: "TRACEDATA[2]", description: "Trace Data 2", required: false, requiresClock: false, specificPin: "P2.09" },
                { name: "TRACEDATA[3]", description: "Trace Data 3", required: false, requiresClock: false, specificPin: "P2.10" }
            ]
        };
        
        // Global state
        let selectedPeripherals = [];
        let usedPins = {};
        let currentPeripheral = null;
        let currentCategory = null;
        let tempSelectedPins = {}; // Used for storing pin selections temporarily during modal dialog
        let currentPackage = "QFN-48"; // Default package
        
        // Helper function to get peripheral functions based on category and peripheral
        function getPeripheralFunctions(category, peripheral) {
            // For most peripherals, we can use the base name to look up functions
            let baseName = peripheral.id.replace(/\d+$/, '');
            
            // Special cases for peripherals with different naming patterns
            if (baseName.includes('SPIM/SPIS')) {
                baseName = 'SPI';
            } else if (baseName.includes('TWIM/TWIS')) {
                baseName = 'I2C';
            } else if (baseName.includes('UARTE')) {
                baseName = 'UART';
            } else if (baseName.includes('PDM')) {
                baseName = 'PDM';
            } else if (baseName.includes('PWM')) {
                baseName = 'PWM';
            } else if (baseName.includes('I2S')) {
                baseName = 'I2S';
            } else if (baseName.includes('QDEC')) {
                baseName = 'QDEC';
            } else if (baseName.includes('NFCT')) {
                baseName = 'NFCT';
            }
            
            // Return the functions for this peripheral type
            return peripheralFunctions[baseName] || [];
        }
        
        // Helper function to check if a function is required
        function isRequiredFunction(category, functionName) {
            // Get the base category name
            let baseName = category;
            if (category.includes('SPI')) {
                baseName = 'SPI';
            } else if (category.includes('I2C') || category.includes('TWIM')) {
                baseName = 'I2C';
            } else if (category.includes('UART')) {
                baseName = 'UART';
            }
            
            // Look up the function in the peripheralFunctions
            const functions = peripheralFunctions[baseName] || [];
            const func = functions.find(f => f.name === functionName);
            
            // Return whether the function is required
            return func ? !!func.required : false;
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing nRF54L Pin Planner...");
            
            // Organize peripherals into single and multi-instance categories
            organizePeripherals();
            
            // Create pin layout
            createPinLayout();
            
            // Set up event listeners
            document.getElementById('clearAllBtn').addEventListener('click', clearAllPeripherals);
            document.getElementById('exportBtn').addEventListener('click', exportConfiguration);
            document.getElementById('searchPeripherals').addEventListener('input', filterPeripherals);
            
            // Simple peripherals checkboxes
            document.getElementById('xl1xl2-checkbox').addEventListener('change', toggleXL1XL2);
            document.getElementById('nfc-checkbox').addEventListener('change', toggleNFC);
            
            // Modal event listeners
            document.querySelector('.close').addEventListener('click', closePinSelectionModal);
            document.getElementById('cancelPinSelection').addEventListener('click', closePinSelectionModal);
            document.getElementById('confirmPinSelection').addEventListener('click', confirmPinSelection);
            
            // Package selection
            document.getElementById('packageSelector').addEventListener('change', handlePackageChange);
            
            // Set HF Crystal pins as system requirement (always on)
            setHFXtalAsSystemRequirement();
            
            // Log that initialization is complete
            console.log("Initialization complete. Peripherals loaded:", 
                Object.keys(peripherals).map(cat => `${cat}: ${peripherals[cat].length}`));
        });
        
        // Organize peripherals into single and multi-instance categories
        function organizePeripherals() {
            // Helper function to get the base name of a peripheral (without number)
            function getBaseName(id) {
                return id.replace(/\d+$/, '');
            }
            
            // Create maps to track instances of peripherals by base name
            const peripheralCounts = {};
            const peripheralsByBase = {};
            
            // Count instances of each peripheral by base name
            for (const category in peripherals) {
                peripherals[category].forEach(peripheral => {
                    // Extract base name (remove trailing numbers)
                    let baseName = getBaseName(peripheral.id);
                    
                    // Special case for SPI because the naming is inconsistent
                    if (baseName.includes('SPIM/SPIS')) {
                        baseName = 'SPIM/SPIS';
                    }
                    
                    // Initialize counters if needed
                    if (!peripheralCounts[baseName]) {
                        peripheralCounts[baseName] = 0;
                        peripheralsByBase[baseName] = [];
                    }
                    
                    // Count this instance
                    peripheralCounts[baseName]++;
                    
                    // Store this peripheral with its category
                    peripheralsByBase[baseName].push({ peripheral, category });
                });
            }
            
            // Clear containers
            const singleContainer = document.getElementById('single-peripherals-container');
            const accordionContainer = document.getElementById('peripheralAccordion');
            singleContainer.innerHTML = '';
            accordionContainer.innerHTML = '';
            
            // Process single-instance peripherals
            for (const baseName in peripheralCounts) {
                if (peripheralCounts[baseName] === 1) {
                    // Single instance - add as button
                    const peripheral = peripheralsByBase[baseName][0].peripheral;
                    const category = peripheralsByBase[baseName][0].category;
                    
                    const btn = document.createElement('button');
                    btn.className = 'single-peripheral-btn';
                    btn.dataset.id = peripheral.id;
                    btn.dataset.category = category;
                    btn.textContent = `${peripheral.id} (${peripheral.port})`;
                    
                    btn.addEventListener('click', function() {
                        // Check if peripheral is already selected - allow editing if it is
                        const isSelected = this.classList.contains('selected');
                        if (isSelected) {
                            // Open for editing
                            editPeripheral(peripheral.id);
                        } else {
                            openPinSelectionModal(peripheral, category);
                        }
                    });
                    
                    singleContainer.appendChild(btn);
                } else {
                    // Multiple instances - add as accordion item
                    const accordionItem = document.createElement('div');
                    accordionItem.className = 'accordion-item';
                    
                    const header = document.createElement('div');
                    header.className = 'accordion-header';
                    header.dataset.target = `${baseName.replace(/[^a-zA-Z0-9]/g, '')}-content`;
                    
                    header.innerHTML = `
                        <span>${baseName}</span>
                        <span class="expand-icon"></span>
                    `;
                    
                    const content = document.createElement('div');
                    content.className = 'accordion-content';
                    content.id = `${baseName.replace(/[^a-zA-Z0-9]/g, '')}-content`;
                    
                    // Add all instances to the content
                    peripheralsByBase[baseName].forEach(item => {
                        const peripheralItem = document.createElement('div');
                        peripheralItem.className = 'peripheral-item';
                        peripheralItem.dataset.id = item.peripheral.id;
                        peripheralItem.dataset.category = item.category;
                        
                        peripheralItem.innerHTML = `
                            <span>${item.peripheral.id}</span>
                            <span>${item.peripheral.port}</span>
                        `;
                        
                        peripheralItem.addEventListener('click', function() {
                            if (this.classList.contains('selected')) {
                                // If already selected, open for editing
                                editPeripheral(item.peripheral.id);
                            } else if (!this.classList.contains('disabled')) {
                                openPinSelectionModal(item.peripheral, item.category);
                            }
                        });
                        
                        content.appendChild(peripheralItem);
                    });
                    
                    accordionItem.appendChild(header);
                    accordionItem.appendChild(content);
                    accordionContainer.appendChild(accordionItem);
                }
            }
            
            // Set up accordion functionality
            setupAccordionMenu();
        }
        
        // Set up accordion menu functionality
        function setupAccordionMenu() {
            const accordionHeaders = document.querySelectorAll('.accordion-header');
            
            accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const target = this.dataset.target;
                    const content = document.getElementById(target);
                    
                    // Toggle active class on header
                    this.classList.toggle('active');
                    
                    // Toggle content display
                    if (content.classList.contains('active')) {
                        content.classList.remove('active');
                    } else {
                        // Close all other active panels first
                        document.querySelectorAll('.accordion-content.active').forEach(item => {
                            if (item.id !== target) {
                                item.classList.remove('active');
                                const relatedHeader = document.querySelector(`.accordion-header[data-target="${item.id}"]`);
                                if (relatedHeader) {
                                    relatedHeader.classList.remove('active');
                                }
                            }
                        });
                        
                        // Open this panel
                        content.classList.add('active');
                    }
                });
            });
        }
        
        // Handle package selection change
        function handlePackageChange(event) {
            const newPackage = event.target.value;
            
            // Only react if selection actually changed
            if (newPackage !== currentPackage) {
                currentPackage = newPackage;
                
                // Update the chip title display
                document.getElementById('chipTitleDisplay').textContent = `${currentPackage} Pin Layout`;
                
                // In the future, this would redraw the chip based on the selected package
                // For now, we'll just show a message
                if (newPackage === "WLCSP") {
                    alert("WLCSP package support is coming soon!");
                    event.target.value = "QFN-48"; // Reset to QFN-48 for now
                    currentPackage = "QFN-48";
                } else {
                    // Recreate the pin layout for QFN-48
                    createPinLayout();
                    updatePinDisplay();
                }
            }
        }
        
        // Set HF Crystal (XC1/XC2) as system requirement that's always enabled
        function setHFXtalAsSystemRequirement() {
            const pins = ["XC1", "XC2"];
            
            // Assign pins
            usedPins[pins[0]] = {
                peripheral: "32 MHz Crystal",
                function: "XC1",
                required: true,
                isSystem: true
            };
            
            usedPins[pins[1]] = {
                peripheral: "32 MHz Crystal",
                function: "XC2",
                required: true,
                isSystem: true
            };
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Toggle XL1/XL2 pins
        function toggleXL1XL2(event) {
            const pins = ["P1.00", "P1.01"];
            const checked = event.target.checked;
            
            if (checked) {
                // Check if pins are already in use
                if (pins.some(pin => usedPins[pin])) {
                    alert("One or both XL1/XL2 pins (P1.00, P1.01) are already in use.");
                    event.target.checked = false;
                    return;
                }
                
                // Assign pins
                usedPins[pins[0]] = {
                    peripheral: "32.768 kHz Crystal",
                    function: "XL1",
                    required: true
                };
                usedPins[pins[1]] = {
                    peripheral: "32.768 kHz Crystal",
                    function: "XL2",
                    required: true
                };
                
                // Add to selected peripherals
                selectedPeripherals.push({
                    id: "32.768 kHz Crystal",
                    category: "Simple",
                    peripheral: { id: "32.768 kHz Crystal", port: "P1", pins: "P1.00 && P1.01", notes: "Required for low-power operation" },
                    pinFunctions: {
                        "P1.00": "XL1",
                        "P1.01": "XL2"
                    }
                });
            } else {
                // Remove from selected peripherals
                const index = selectedPeripherals.findIndex(p => p.id === "32.768 kHz Crystal");
                if (index !== -1) {
                    selectedPeripherals.splice(index, 1);
                }
                
                // Remove pin assignments
                pins.forEach(pin => {
                    if (usedPins[pin] && usedPins[pin].peripheral === "32.768 kHz Crystal") {
                        delete usedPins[pin];
                    }
                });
            }
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Clear all peripherals
        function clearAllPeripherals() {
            // Confirm with the user
            if (!confirm('Are you sure you want to clear all peripherals? This action cannot be undone.')) {
                return;
            }
            
            // Clear all selected peripherals except system ones
            selectedPeripherals = selectedPeripherals.filter(p => {
                const isSystem = Object.values(p.pinFunctions).some(func => {
                    const pin = Object.keys(p.pinFunctions).find(pin => p.pinFunctions[pin] === func);
                    return usedPins[pin] && usedPins[pin].isSystem;
                });
                return isSystem;
            });
            
            // Clear all used pins except system ones
            for (const pin in usedPins) {
                if (!usedPins[pin].isSystem) {
                    delete usedPins[pin];
                }
            }
            
            // Reset checkboxes
            document.getElementById('xl1xl2-checkbox').checked = false;
            document.getElementById('nfc-checkbox').checked = false;
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Export configuration
        function exportConfiguration() {
            // Create a configuration object
            const config = {
                package: currentPackage,
                peripherals: selectedPeripherals.map(p => ({
                    id: p.id,
                    category: p.category,
                    pinAssignments: p.pinFunctions
                })),
                pinAssignments: Object.keys(usedPins).map(pin => ({
                    pin: pin,
                    peripheral: usedPins[pin].peripheral,
                    function: usedPins[pin].function,
                    required: usedPins[pin].required,
                    isSystem: usedPins[pin].isSystem || false
                }))
            };
            
            // Convert to JSON
            const jsonConfig = JSON.stringify(config, null, 2);
            
            // Create a blob and download link
            const blob = new Blob([jsonConfig], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `nrf-pin-config-${currentPackage.toLowerCase()}.json`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Toggle NFC pins
        function toggleNFC(event) {
            const pins = ["P1.02", "P1.03"];
            const checked = event.target.checked;
            
            if (checked) {
                // Check if pins are already in use
                if (pins.some(pin => usedPins[pin])) {
                    alert("One or both NFC pins (P1.02, P1.03) are already in use.");
                    event.target.checked = false;
                    return;
                }
                
                // Assign pins
                usedPins[pins[0]] = {
                    peripheral: "NFC Antenna",
                    function: "NFC1",
                    required: true
                };
                usedPins[pins[1]] = {
                    peripheral: "NFC Antenna",
                    function: "NFC2",
                    required: true
                };
                
                // Add to selected peripherals
                selectedPeripherals.push({
                    id: "NFC Antenna",
                    category: "Simple",
                    peripheral: { id: "NFC Antenna", port: "P1", pins: "P1.02 && P1.03", notes: "Required for NFC functionality" },
                    pinFunctions: {
                        "P1.02": "NFC1",
                        "P1.03": "NFC2"
                    }
                });
            } else {
                // Remove from selected peripherals
                const index = selectedPeripherals.findIndex(p => p.id === "NFC Antenna");
                if (index !== -1) {
                    selectedPeripherals.splice(index, 1);
                }
                
                // Remove pin assignments
                pins.forEach(pin => {
                    if (usedPins[pin] && usedPins[pin].peripheral === "NFC Antenna") {
                        delete usedPins[pin];
                    }
                });
            }
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Create pin layout for the chip
        function createPinLayout() {
            const chipContainer = document.querySelector('.chip-container');
            
            // Clear existing content
            chipContainer.innerHTML = '';
            
            // Create the chip body
            const chipBody = document.createElement('div');
            chipBody.className = 'chip-body';
            chipContainer.appendChild(chipBody);
            
            // Calculate positions
            const chipSize = 420;
            const pinSize = 20;
            const pinSpacing = (400 - 2 * pinSize) / 11; // 12 pins per side
            const offset = 20; // offset from edge for chip body
            
            // Create all 48 pins
            for (let i = 1; i <= 48; i++) {
                const pinData = getPinDataByNumber(i);
                const pin = document.createElement('div');
                pin.className = 'pin';
                pin.dataset.number = i;
                pin.dataset.name = pinData.name;
                pin.textContent = i;
                
                // Add special classes based on pin type
                if (pinData.type === 'vdd' || pinData.type === 'vss' || pinData.type === 'debug') {
                    pin.classList.add(pinData.type);
                } else if (pinData.isClock) {
                    pin.classList.add('clock');
                }
                
                // Special handling for XC1/XC2 crystal pins
                if (pinData.name === "XC1" || pinData.name === "XC2") {
                    pin.classList.add('system');
                }
                
                // Position the pin based on its number
                if (i <= 12) {
                    // Left side pins (1-12)
                    pin.style.left = '0px';
                    pin.style.top = (pinSize + (i-1) * pinSpacing) + 'px';
                    pin.style.transform = 'translateX(-50%)';
                } else if (i <= 24) {
                    // Bottom side pins (13-24)
                    pin.style.bottom = '0px';
                    pin.style.left = (pinSize + (i-13) * pinSpacing) + 'px';
                    pin.style.transform = 'translateY(50%)';
                } else if (i <= 36) {
                    // Right side pins (25-36)
                    pin.style.right = '0px';
                    pin.style.top = (chipSize - offset - pinSize - (i-25) * pinSpacing) + 'px';
                    pin.style.transform = 'translateX(50%)';
                } else {
                    // Top side pins (37-48)
                    pin.style.top = '0px';
                    pin.style.left = (chipSize - offset - pinSize - (i-37) * pinSpacing) + 'px';
                    pin.style.transform = 'translateY(-50%)';
                }
                
                // Add click event to show pin details
                pin.addEventListener('click', function() {
                    showPinDetails(pinData);
                });
                
                chipContainer.appendChild(pin);
            }
        }
        
        // Get pin data by pin number
        function getPinDataByNumber(number) {
            return pinData.find(pin => pin.number === number) || { name: 'Unknown', type: 'unknown' };
        }
        
        // Get pin data by pin name
        function getPinDataByName(name) {
            return pinData.find(pin => pin.name === name) || null;
        }
        
        // Show pin details in the details panel
        function showPinDetails(pin) {
            const detailsElement = document.getElementById('pinDetails');
            
            let usedBy = '';
            if (usedPins[pin.name]) {
                const usage = usedPins[pin.name];
                const systemBadge = usage.isSystem ? '<span class="system-peripheral">[System]</span> ' : '';
                usedBy = `<p><strong>Used by:</strong> ${systemBadge}${usage.peripheral} (${usage.function})</p>`;
            }
            
            let functionsHtml = '';
            if (pin.functions && pin.functions.length > 0) {
                functionsHtml = `
                    <p><strong>Functions:</strong></p>
                    <ul>
                        ${pin.functions.map(func => `<li>${func}</li>`).join('')}
                    </ul>
                `;
            }
            
            detailsElement.innerHTML = `
                <h3>${pin.name} (Pin ${pin.number})</h3>
                <p><strong>Type:</strong> ${pin.type.toUpperCase()}</p>
                ${pin.isClock ? '<p><strong>Clock capable</strong></p>' : ''}
                ${usedBy}
                ${functionsHtml}
            `;
        }
        
        // Edit an existing peripheral
        function editPeripheral(peripheralId) {
            // Find the peripheral in the selected list
            const peripheralIndex = selectedPeripherals.findIndex(p => p.id === peripheralId);
            if (peripheralIndex === -1) return;
            
            const selectedPeripheral = selectedPeripherals[peripheralIndex];
            
            // Store original configuration to revert if needed
            const originalPinConfig = { ...selectedPeripheral.pinFunctions };
            const originalCategory = selectedPeripheral.category;
            
            // Find the peripheral data
            let peripheralData = null;
            let category = originalCategory;
            
            // Search for the peripheral in all categories
            for (const cat in peripherals) {
                const found = peripherals[cat].find(p => p.id === peripheralId);
                if (found) {
                    peripheralData = found;
                    category = cat;
                    break;
                }
            }
            
            if (!peripheralData) {
                console.error(`Could not find peripheral data for ${peripheralId}`);
                return;
            }
            
            // Store current editing state
            currentPeripheral = peripheralData;
            currentCategory = category;
            tempSelectedPins = { ...originalPinConfig };
            
            // Set modal title to indicate editing
            document.getElementById('modalTitle').textContent = `Edit Pins for ${peripheralId}`;
            
            // Get the functions for this peripheral type
            let functionsToUse = getPeripheralFunctions(category, peripheralData);
            
            // First, remove current pin assignments temporarily
            for (const pinName in originalPinConfig) {
                delete usedPins[pinName];
            }
            
            // Populate the pin selection table
            populatePinSelectionTable(functionsToUse, peripheralData);
            
            // Pre-select pins according to existing configuration
            preSelectPins(originalPinConfig, functionsToUse);
            
            // Show the modal
            document.getElementById('pinSelectionModal').style.display = 'block';
            
            // Add event handlers for cancel/confirm that handle editing
            document.getElementById('cancelPinSelection').onclick = function() {
                // Restore original pin configuration
                for (const [pinName, funcName] of Object.entries(originalPinConfig)) {
                    usedPins[pinName] = {
                        peripheral: peripheralId,
                        function: funcName,
                        required: isRequiredFunction(category, funcName)
                    };
                }
                
                closePinSelectionModal();
            };
            
            document.getElementById('confirmPinSelection').onclick = function() {
                const result = updatePeripheralPins(peripheralIndex, peripheralData, category);
                if (result) {
                    closePinSelectionModal();
                }
            };
        }
        
        // Pre-select pins in the modal based on existing configuration
        function preSelectPins(pinConfig, functions) {
            // Handle GPIOTE case specially
            if (currentPeripheral.id.includes('GPIOTE')) {
                // For GPIOTE, we need to associate pins with channel numbers
                // Extract channel numbers from function names in pinConfig
                for (const [pinName, funcName] of Object.entries(pinConfig)) {
                    // Function name format: "GPIOTE PIN-0", "GPIOTE PIN-1", etc.
                    const channelMatch = funcName.match(/GPIOTE PIN-(\d+)/);
                    if (channelMatch) {
                        const channelNum = parseInt(channelMatch[1]);
                        const selectId = `select-gpiote-pin-${channelNum}`;
                        const select = document.getElementById(selectId);
                        
                        if (select) {
                            select.value = pinName;
                        }
                    }
                }
                
                return;
            }
            if (currentPeripheral.id === "TAMPC") {
                // For each shield pair, check if both pins are assigned
                functions.forEach(func => {
                    if (pinConfig[func.outputPin] && pinConfig[func.inputPin]) {
                        const checkbox = document.getElementById(`checkbox-${func.name.replace(/\s+/g, '-')}`);
                        if (checkbox) checkbox.checked = true;
                    }
                });
                return;
            }
            
            // Handle SAADC case specially
            if (currentPeripheral.id === "SAADC") {
                // Check all AIN checkboxes that are assigned
                for (const pinName in pinConfig) {
                    const funcName = pinConfig[pinName];
                    const checkbox = document.getElementById(`checkbox-${funcName}`);
                    if (checkbox) checkbox.checked = true;
                }
                return;
            }
            
            // For regular peripherals with dropdowns
            for (const pinName in pinConfig) {
                const funcName = pinConfig[pinName];
                
                // Find if there is a dropdown for this function
                const selectId = `select-${funcName.replace(/\s+/g, '-').toLowerCase()}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    select.value = pinName;
                }
                
                // Also handle checkboxes for single-option functions
                const checkboxId = `checkbox-${funcName}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = true;
                }
            }
        }
        
        // Update an existing peripheral with new pin assignments
        function updatePeripheralPins(peripheralIndex, peripheral, category) {
            // Check for pin conflicts with other peripherals
            const conflictingPins = [];
            for (const pinName of Object.keys(tempSelectedPins)) {
                if (usedPins[pinName]) {
                    conflictingPins.push(`${pinName} (used by ${usedPins[pinName].peripheral})`);
                }
            }
            
            if (conflictingPins.length > 0) {
                alert(`Cannot assign pins due to conflicts:\n${conflictingPins.join('\n')}`);
                return false;
            }
            
            // Update the peripheral's pin functions
            selectedPeripherals[peripheralIndex].pinFunctions = { ...tempSelectedPins };
            
            // Assign the selected pins
            for (const [pinName, funcName] of Object.entries(tempSelectedPins)) {
                usedPins[pinName] = {
                    peripheral: peripheral.id,
                    function: funcName,
                    required: isRequiredFunction(category, funcName)
                };
            }
            
            // Update the UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
            
            return true;
        }
        
        // Open the pin selection modal for a peripheral
        function openPinSelectionModal(peripheral, category) {
            // Set the current peripheral and category
            currentPeripheral = peripheral;
            currentCategory = category;
            
            // Set the modal title
            document.getElementById('modalTitle').textContent = `Select Pins for ${peripheral.id}`;
            
            // Get the functions for this peripheral type
            let functionsToUse = getPeripheralFunctions(category, peripheral);
            
            // Populate the pin selection table
            populatePinSelectionTable(functionsToUse, peripheral);
            
            // Show the modal
            document.getElementById('pinSelectionModal').style.display = 'block';
        }
        
        // Confirm pin selection
        function confirmPinSelection() {
            // Check if all required functions have pins assigned
            if (currentPeripheral && currentCategory) {
                const functions = getPeripheralFunctions(currentCategory, currentPeripheral);
                const requiredFunctions = functions.filter(f => f.required);
                
                // For GPIOTE, there are no required functions
                if (currentPeripheral.id.includes('GPIOTE')) {
                    // Just check if at least one pin is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one pin for the GPIOTE peripheral.');
                        return;
                    }
                } 
                // For TAMPC, no specific requirements
                else if (currentPeripheral.id === 'TAMPC') {
                    // Just check if at least one shield pair is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one shield pair for the TAMPC peripheral.');
                        return;
                    }
                }
                // For SAADC, no specific requirements
                else if (currentPeripheral.id === 'SAADC') {
                    // Just check if at least one analog input is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one analog input for the SAADC peripheral.');
                        return;
                    }
                }
                // For other peripherals, check required functions
                else {
                    for (const func of requiredFunctions) {
                        // Check if this function has a pin assigned
                        const hasPin = Object.values(tempSelectedPins).includes(func.name);
                        if (!hasPin) {
                            alert(`Please select a pin for the required function: ${func.name}`);
                            return;
                        }
                    }
                }
                
                // Check for pin conflicts with other peripherals
                const conflictingPins = [];
                for (const pinName of Object.keys(tempSelectedPins)) {
                    if (usedPins[pinName] && 
                        (!currentPeripheral || usedPins[pinName].peripheral !== currentPeripheral.id)) {
                        conflictingPins.push(`${pinName} (used by ${usedPins[pinName].peripheral})`);
                    }
                }
                
                if (conflictingPins.length > 0) {
                    alert(`Cannot assign pins due to conflicts:\n${conflictingPins.join('\n')}`);
                    return;
                }
                
                // All checks passed, add the peripheral
                const peripheralConfig = {
                    id: currentPeripheral.id,
                    category: currentCategory,
                    peripheral: currentPeripheral,
                    pinFunctions: { ...tempSelectedPins }
                };
                
                // Check if this peripheral is already in the list (for editing)
                const existingIndex = selectedPeripherals.findIndex(p => p.id === currentPeripheral.id);
                if (existingIndex !== -1) {
                    // Remove old pin assignments
                    const oldPinFunctions = selectedPeripherals[existingIndex].pinFunctions;
                    for (const pinName in oldPinFunctions) {
                        delete usedPins[pinName];
                    }
                    
                    // Update the peripheral
                    selectedPeripherals[existingIndex] = peripheralConfig;
                } else {
                    // Add new peripheral
                    selectedPeripherals.push(peripheralConfig);
                }
                
                // Assign the selected pins
                for (const [pinName, funcName] of Object.entries(tempSelectedPins)) {
                    usedPins[pinName] = {
                        peripheral: currentPeripheral.id,
                        function: funcName,
                        required: isRequiredFunction(currentCategory, funcName)
                    };
                }
                
                // Update the UI
                updateSelectedPeripheralsList();
                updatePinDisplay();
                
                // Close the modal
                closePinSelectionModal();
            }
        }
        
        // Close the pin selection modal
        function closePinSelectionModal() {
            document.getElementById('pinSelectionModal').style.display = 'none';
            
            // Reset handlers to default
            document.getElementById('cancelPinSelection').onclick = function() {
                closePinSelectionModal();
            };
            
            document.getElementById('confirmPinSelection').onclick = confirmPinSelection;
            
            currentPeripheral = null;
            currentCategory = null;
            tempSelectedPins = {};
        }
        
        // Check if a function has only one possible pin option
        function hasOnlyOneOption(func, allowedPorts) {
            // If it has a specific pin, it definitely has only one option
            if (func.specificPin) {
                return true;
            }
            
            // Count the number of pins that match the requirements
            let count = 0;
            for (const pin of pinData) {
                // Must be an I/O pin
                if (pin.type !== 'io') continue;
                
                // Must be in an allowed port
                if (!allowedPorts.includes(pin.port)) continue;
                
                // If clock is required, the pin must support it
                if (func.requiresClock && !pin.isClock) continue;
                
                // Pin must not be already used by another peripheral
                if (usedPins[pin.name]) continue;
                
                count++;
                if (count > 1) return false; // More than one option
            }
            
            return count === 1; // True if exactly one option
        }
        
        // Get the ports that a peripheral can use
        function getPortsForPeripheral(peripheral) {
            const portStr = peripheral.port;
            if (portStr === "Mixed") {
                return ["P0", "P1", "P2"];
            }
            
            const ports = [];
            if (portStr.includes("Port 0")) ports.push("P0");
            if (portStr.includes("Port 1")) ports.push("P1");
            if (portStr.includes("Port 2")) ports.push("P2");
            
            return ports;
        }
        
        // Populate select options with compatible pins
        function populatePinSelectOptions(select, func, allowedPorts) {
            // If there's a specific pin required for this function
            if (func.specificPin) {
                const pin = getPinDataByName(func.specificPin);
                if (pin) {
                    const option = new Option(`${pin.name} (Pin ${pin.number})`, pin.name);
                    select.add(option);
                    if (func.required) {
                        select.value = pin.name;
                        select.disabled = true;
                    }
                }
                return;
            }
            
            // Get all available pins that match the requirements
            const availablePins = pinData.filter(pin => {
                // Must be an I/O pin
                if (pin.type !== 'io') return false;
                
                // Must be in an allowed port
                if (!allowedPorts.includes(pin.port)) return false;
                
                // If clock is required, the pin must support it
                if (func.requiresClock && !pin.isClock) return false;
                
                // Pin must not be already used by another peripheral
                if (usedPins[pin.name]) return false;
                
                // Pin must not be temporarily selected for another function in the current dialog
                if (tempSelectedPins[pin.name] && tempSelectedPins[pin.name] !== func.name) return false;
                
                return true;
            });
            
            // Add options for each available pin
            availablePins.forEach(pin => {
                const option = new Option(`${pin.name} (Pin ${pin.number})${pin.isClock ? ' - Clock' : ''}`, pin.name);
                select.add(option);
            });
            
            // If no pins are available, add a disabled option
            if (availablePins.length === 0) {
                const option = new Option('No compatible pins available', '');
                option.disabled = true;
                select.add(option);
            }
        }
        
        // Populate the pin selection table with functions and available pins
        function populatePinSelectionTable(functions, peripheral) {
            const tableBody = document.getElementById('pinSelectionTableBody');
            tableBody.innerHTML = '';
            
            // Get the ports this peripheral can use
            const ports = getPortsForPeripheral(peripheral);
            
            // Initialize tempSelectedPins
            tempSelectedPins = {};
            
            // Check if this is GPIOTE - special case for channel handling
            if (peripheral.id.includes('GPIOTE')) {
                // Create header row explaining GPIOTE channels
                const headerRow = document.createElement('tr');
                const maxChannels = peripheral.id === "GPIOTE20" ? 8 : 4;
                
                headerRow.innerHTML = `
                    <td colspan="4" style="background-color: #f0f0f0; text-align: center;">
                        <strong>${peripheral.id} - ${maxChannels} Channels</strong><br>
                        Each channel can be assigned to one pin. Select which pins to use for each channel.
                    </td>
                `;
                tableBody.appendChild(headerRow);
                
                // Create a filtered list of ports for this GPIOTE instance
                let filteredPorts = [...ports];
                if (peripheral.id === "GPIOTE20") {
                    // Only P1 pins for GPIOTE20
                    filteredPorts = ["P1"];
                } else if (peripheral.id === "GPIOTE30") {
                    // Only P0 pins for GPIOTE30
                    filteredPorts = ["P0"];
                }
                
                // Get the correct function list based on the peripheral ID
                const gpioteFunctions = peripheral.id === "GPIOTE20" ? 
                                        peripheralFunctions.GPIOTE20 : 
                                        peripheralFunctions.GPIOTE30;
                
                // Add each channel as a separate row with pin selection
                gpioteFunctions.forEach(func => {
                    const row = document.createElement('tr');
                    
                    // Create cells for function name and required status
                    const funcNameCell = document.createElement('td');
                    funcNameCell.textContent = func.name;
                    
                    const requiredCell = document.createElement('td');
                    requiredCell.textContent = func.required ? 'Yes' : 'No';
                    
                    const selectionCell = document.createElement('td');
                    
                    // Create dropdown for pin selection
                    const select = document.createElement('select');
                    select.id = `select-gpiote-pin-${func.channel}`;
                    select.dataset.function = func.name;
                    select.dataset.channel = func.channel;
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- Select Pin --';
                    select.appendChild(defaultOption);
                    
                    // Add change event listener
                    select.addEventListener('change', function() {
                        const selectedPin = this.value;
                        const functionName = this.dataset.function;
                        
                        // If a pin was previously selected for this function, remove it from tempSelectedPins
                        Object.keys(tempSelectedPins).forEach(pin => {
                            if (tempSelectedPins[pin] === functionName) {
                                delete tempSelectedPins[pin];
                            }
                        });
                        
                        // If a new pin is selected, add it to tempSelectedPins
                        if (selectedPin) {
                            tempSelectedPins[selectedPin] = functionName;
                        }
                        
                        // Update all GPIOTE dropdowns to reflect the new selection
                        updateGpioteDropdowns(gpioteFunctions, filteredPorts);
                    });
                    
                    selectionCell.appendChild(select);
                    
                    // We'll populate all GPIOTE dropdowns at once after all are created
                    
                    const notesCell = document.createElement('td');
                    notesCell.textContent = `Channel ${func.channel} - can be assigned to one pin`;
                    
                    row.appendChild(funcNameCell);
                    row.appendChild(requiredCell);
                    row.appendChild(selectionCell);
                    row.appendChild(notesCell);
                    
                    tableBody.appendChild(row);
                });
                
                // Populate all GPIOTE dropdowns at once
                updateGpioteDropdowns(gpioteFunctions, filteredPorts);
                
                return; // Skip the standard function handling
            }
            
            // Check if this is TAMPC - special case for paired pins
            if (peripheral.id === "TAMPC") {
                // Create header row explaining the pin pairs
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <td colspan="4" style="background-color: #f0f0f0; text-align: center;">
                        <strong>TAMPC Active Shield Pairs</strong><br>
                        Each shield consists of an output (ASO) and input (ASI) pin pair that must be used together
                    </td>
                `;
                tableBody.appendChild(headerRow);
                
                // Add each shield pair as a row with a checkbox
                functions.forEach(func => {
                    const row = document.createElement('tr');
                    
                    // Create cells for function name and required status
                    const funcNameCell = document.createElement('td');
                    funcNameCell.textContent = func.name;
                    
                    const requiredCell = document.createElement('td');
                    requiredCell.textContent = 'No';
                    
                    const selectionCell = document.createElement('td');
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'checkbox-option';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `checkbox-${func.name.replace(/\s+/g, '-')}`;
                    
                    // Check if either pin in the pair is already used
                    const isOutputUsed = !!usedPins[func.outputPin];
                    const isInputUsed = !!usedPins[func.inputPin];
                    
                    if (isOutputUsed || isInputUsed) {
                        checkbox.disabled = true;
                    }
                    
                    // Add change event to handle the paired pins
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            // Add both pins of the pair
                            tempSelectedPins[func.outputPin] = func.outputFunc;
                            tempSelectedPins[func.inputPin] = func.inputFunc;
                        } else {
                            // Remove both pins of the pair
                            delete tempSelectedPins[func.outputPin];
                            delete tempSelectedPins[func.inputPin];
                        }
                    });
                    
                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.innerHTML = `
                        ${func.outputPin} (${func.outputFunc}) and ${func.inputPin} (${func.inputFunc})
                    `;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    selectionCell.appendChild(checkboxDiv);
                    
                    const notesCell = document.createElement('td');
                    notesCell.textContent = `Both pins must be used together`;
                    
                    row.appendChild(funcNameCell);
                    row.appendChild(requiredCell);
                    row.appendChild(selectionCell);
                    row.appendChild(notesCell);
                    
                    tableBody.appendChild(row);
                });
                
                return; // Skip the standard function handling
            }
            
            // Check if this is SAADC - special case for checkbox selection
            const isSAADC = peripheral.id === "SAADC";
            
            // For each function, create a row with either checkboxes or dropdown
            functions.forEach(func => {
                const row = document.createElement('tr');
                
                // Create cells for function name and required status
                const funcNameCell = document.createElement('td');
                funcNameCell.textContent = func.name;
                
                const requiredCell = document.createElement('td');
                requiredCell.textContent = func.required ? 'Yes' : 'No';
                
                const selectionCell = document.createElement('td');
                const notesCell = document.createElement('td');
                notesCell.textContent = func.requiresClock ? 'Requires clock pin' : '';
                
                // Add cells to row
                row.appendChild(funcNameCell);
                row.appendChild(requiredCell);
                row.appendChild(selectionCell);
                row.appendChild(notesCell);
                
                // Special case for SAADC or if the function has only one pin option - use checkboxes
                if (isSAADC || hasOnlyOneOption(func, ports)) {
                    // Create a div for the checkbox options
                    const checkboxOptions = document.createElement('div');
                    checkboxOptions.className = 'checkbox-options';
                    
                    // If specific pin is defined or only one pin is available
                    if (func.specificPin) {
                        // Add a single checkbox for the specific pin
                        const pin = getPinDataByName(func.specificPin);
                        
                        if (pin) {
                            const checkboxOption = document.createElement('div');
                            checkboxOption.className = 'checkbox-option';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `checkbox-${func.name}`;
                            checkbox.value = pin.name;
                            checkbox.dataset.function = func.name;
                            
                            // Check if pin is already used
                            const isPinUsed = !!usedPins[pin.name];
                            if (isPinUsed) {
                                checkbox.disabled = true;
                            }
                            
                            // Add change event
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    tempSelectedPins[this.value] = this.dataset.function;
                                } else {
                                    delete tempSelectedPins[this.value];
                                }
                            });
                            
                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = `${pin.name} (Pin ${pin.number})`;
                            
                            checkboxOption.appendChild(checkbox);
                            checkboxOption.appendChild(label);
                            checkboxOptions.appendChild(checkboxOption);
                        }
                    } else {
                        // Find the only available pin
                        const availablePins = pinData.filter(pin => {
                            // Must be an I/O pin
                            if (pin.type !== 'io') return false;
                            
                            // Must be in an allowed port
                            if (!ports.includes(pin.port)) return false;
                            
                            // If clock is required, the pin must support it
                            if (func.requiresClock && !pin.isClock) return false;
                            
                            // Pin must not be already used by another peripheral
                            if (usedPins[pin.name]) return false;
                            
                            return true;
                        });
                        
                        if (availablePins.length === 1) {
                            const pin = availablePins[0];
                            const checkboxOption = document.createElement('div');
                            checkboxOption.className = 'checkbox-option';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `checkbox-${func.name}`;
                            checkbox.value = pin.name;
                            checkbox.dataset.function = func.name;
                            
                            // If function is required, check by default
                            if (func.required) {
                                checkbox.checked = true;
                                tempSelectedPins[pin.name] = func.name;
                            }
                            
                            // Add change event
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    tempSelectedPins[this.value] = this.dataset.function;
                                } else {
                                    delete tempSelectedPins[this.value];
                                }
                            });
                            
                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = `${pin.name} (Pin ${pin.number})`;
                            
                            checkboxOption.appendChild(checkbox);
                            checkboxOption.appendChild(label);
                            checkboxOptions.appendChild(checkboxOption);
                        }
                    }
                    
                    selectionCell.appendChild(checkboxOptions);
                } else {
                    // Regular dropdown selection for multiple options
                    const select = document.createElement('select');
                    select.id = `select-${func.name.replace(/\s+/g, '-').toLowerCase()}`;
                    select.dataset.function = func.name;
                    if (func.required) {
                        select.required = true;
                    }
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- Select Pin --';
                    select.appendChild(defaultOption);
                    
                    // Add change event listener
                    select.addEventListener('change', function() {
                        const selectedPin = this.value;
                        const functionName = this.dataset.function;
                        
                        // If a pin was previously selected for this function, remove it from tempSelectedPins
                        Object.keys(tempSelectedPins).forEach(pin => {
                            if (tempSelectedPins[pin] === functionName) {
                                delete tempSelectedPins[pin];
                            }
                        });
                        
                        // If a new pin is selected, add it to tempSelectedPins
                        if (selectedPin) {
                            tempSelectedPins[selectedPin] = functionName;
                        }
                        
                        // Update all dropdowns to reflect the new selection
                        updateAllPinDropdowns(functions, ports);
                    });
                    
                    selectionCell.appendChild(select);
                    
                    // Populate the select with compatible pins
                    populatePinSelectOptions(select, func, ports);
                }
                
                tableBody.appendChild(row);
            });
        }
        
        // Update all pin dropdowns in the modal
        function updateAllPinDropdowns(functions, ports) {
            functions.forEach(func => {
                const selectId = `select-${func.name.replace(/\s+/g, '-').toLowerCase()}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    // Save the current selection
                    const currentValue = select.value;
                    
                    // Clear and repopulate options
                    select.innerHTML = '<option value="">-- Select Pin --</option>';
                    populatePinSelectOptions(select, func, ports);
                    
                    // Restore the selection if it's still valid
                    if (currentValue && (select.querySelector(`option[value="${currentValue}"]`))) {
                        select.value = currentValue;
                    }
                }
            });
        }
        
        // Update GPIOTE pin dropdowns to filter out pins already selected in the same peripheral
        function updateGpioteDropdowns(functions, ports) {
            functions.forEach(func => {
                const selectId = `select-gpiote-pin-${func.channel}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    // Save the current selection
                    const currentValue = select.value;
                    
                    // Clear and repopulate options
                    select.innerHTML = '<option value="">-- Select Pin --</option>';
                    
                    // Get all available pins that match the requirements
                    const availablePins = pinData.filter(pin => {
                        // Must be an I/O pin
                        if (pin.type !== 'io') return false;
                        
                        // Must be in an allowed port
                        if (!ports.includes(pin.port)) return false;
                        
                        // Pin must not be already used by another peripheral
                        if (usedPins[pin.name]) return false;
                        
                        // Pin must not be temporarily selected for another GPIOTE function in the current dialog
                        const isAlreadySelectedForGpiote = Object.entries(tempSelectedPins).some(([pinName, funcName]) => {
                            return pinName === pin.name && funcName !== func.name && funcName.includes('GPIOTE PIN');
                        });
                        
                        if (isAlreadySelectedForGpiote) return false;
                        
                        return true;
                    });
                    
                    // Add options for each available pin
                    availablePins.forEach(pin => {
                        const option = new Option(`${pin.name} (Pin ${pin.number})${pin.isClock ? ' - Clock' : ''}`, pin.name);
                        select.add(option);
                    });
                    
                    // If no pins are available, add a disabled option
                    if (availablePins.length === 0) {
                        const option = new Option('No compatible pins available', '');
                        option.disabled = true;
                        select.add(option);
                    }
                    
                    // Restore the selection if it's still valid
                    if (currentValue && (select.querySelector(`option[value="${currentValue}"]`))) {
                        select.value = currentValue;
                    }
                }
            });
        }
        
        // Update the selected peripherals list
        function updateSelectedPeripheralsList() {
            const selectedList = document.getElementById('selectedList');
            selectedList.innerHTML = '';
            
            if (selectedPeripherals.length === 0) {
                const emptyMessage = document.createElement('li');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'No peripherals selected yet.';
                selectedList.appendChild(emptyMessage);
                return;
            }
            
            // Add each peripheral to the list
            selectedPeripherals.forEach(peripheral => {
                const item = document.createElement('li');
                item.className = 'selected-item';
                
                // Check if this is a system peripheral
                const isSystem = Object.values(peripheral.pinFunctions).some(func => {
                    const pin = Object.keys(peripheral.pinFunctions).find(pin => peripheral.pinFunctions[pin] === func);
                    return usedPins[pin] && usedPins[pin].isSystem;
                });
                
                if (isSystem) {
                    item.classList.add('system');
                }
                
                // Create the item content
                const pinList = Object.entries(peripheral.pinFunctions)
                    .map(([pin, func]) => `${pin}: ${func}`)
                    .join(', ');
                
                item.innerHTML = `
                    <div>
                        <strong>${peripheral.id}</strong>
                        <div>${pinList}</div>
                    </div>
                    <button class="remove-btn ${isSystem ? 'disabled' : ''}" 
                            data-id="${peripheral.id}" 
                            ${isSystem ? 'disabled' : ''}>
                        Remove
                    </button>
                `;
                
                // Add event listener to the remove button
                const removeBtn = item.querySelector('.remove-btn');
                if (!isSystem) {
                    removeBtn.addEventListener('click', function() {
                        removePeripheral(peripheral.id);
                    });
                }
                
                selectedList.appendChild(item);
            });
        }
        
        // Remove a peripheral
        function removePeripheral(peripheralId) {
            // Find the peripheral
            const index = selectedPeripherals.findIndex(p => p.id === peripheralId);
            if (index === -1) return;
            
            const peripheral = selectedPeripherals[index];
            
            // Remove pin assignments
            for (const pinName in peripheral.pinFunctions) {
                delete usedPins[pinName];
            }
            
            // Remove from selected peripherals
            selectedPeripherals.splice(index, 1);
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
            
            // Update checkboxes for special peripherals
            if (peripheralId === "32.768 kHz Crystal") {
                document.getElementById('xl1xl2-checkbox').checked = false;
            } else if (peripheralId === "NFC Antenna") {
                document.getElementById('nfc-checkbox').checked = false;
            }
        }
        
        // Update the pin display
        function updatePinDisplay() {
            // Update all pins
            document.querySelectorAll('.pin').forEach(pinElement => {
                const pinName = pinElement.dataset.name;
                
                // Reset classes
                pinElement.classList.remove('used', 'required', 'system');
                
                // Add appropriate classes based on pin usage
                if (usedPins[pinName]) {
                    pinElement.classList.add('used');
                    
                    if (usedPins[pinName].required) {
                        pinElement.classList.add('required');
                    }
                    
                    if (usedPins[pinName].isSystem) {
                        pinElement.classList.add('system');
                    }
                }
            });
        }
        
        // Filter peripherals based on search input
        function filterPeripherals() {
            const searchText = document.getElementById('searchPeripherals').value.toLowerCase();
            
            // Filter single-instance peripherals
            const singlePeripheralButtons = document.querySelectorAll('#single-peripherals-container .single-peripheral-btn');
            singlePeripheralButtons.forEach(button => {
                const peripheralText = button.textContent.toLowerCase();
                if (peripheralText.includes(searchText)) {
                    button.style.display = 'block';
                } else {
                    button.style.display = 'none';
                }
            });
            
            // Filter multi-instance peripherals in accordion
            const accordionItems = document.querySelectorAll('.accordion-item');
            accordionItems.forEach(item => {
                const header = item.querySelector('.accordion-header');
                const content = item.querySelector('.accordion-content');
                const headerText = header.textContent.toLowerCase();
                
                // Check if header matches
                const headerMatches = headerText.includes(searchText);
                
                // Check if any peripheral items in this category match
                const peripheralItems = item.querySelectorAll('.peripheral-item');
                let anyItemMatches = false;
                
                peripheralItems.forEach(pItem => {
                    const pItemText = pItem.textContent.toLowerCase();
                    if (pItemText.includes(searchText)) {
                        pItem.style.display = 'flex';
                        anyItemMatches = true;
                    } else {
                        pItem.style.display = 'none';
                    }
                });
                
                // Show/hide the entire accordion item based on matches
                if (headerMatches || anyItemMatches) {
                    item.style.display = 'block';
                    if (searchText && anyItemMatches) {
                        // Auto-expand accordion if search matches items inside
                        header.classList.add('active');
                        content.classList.add('active');
                    }
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show a message if no results
            const singleContainer = document.getElementById('single-peripherals-container');
            const accordionContainer = document.getElementById('peripheralAccordion');
            
            const noSingleResults = Array.from(singlePeripheralButtons).every(btn => btn.style.display === 'none');
            const noAccordionResults = Array.from(accordionItems).every(item => item.style.display === 'none');
            
            // If search is not empty and no results found, show message
            if (searchText && noSingleResults && noAccordionResults) {
                // Check if message already exists
                let noResultsMsg = document.getElementById('no-results-message');
                if (!noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.id = 'no-results-message';
                    noResultsMsg.style.padding = '10px';
                    noResultsMsg.style.color = '#666';
                    noResultsMsg.style.fontStyle = 'italic';
                    noResultsMsg.style.textAlign = 'center';
                    accordionContainer.parentNode.insertBefore(noResultsMsg, accordionContainer);
                }
                noResultsMsg.textContent = `No peripherals found matching "${searchText}"`;
                noResultsMsg.style.display = 'block';
            } else {
                // Hide message if it exists
                const noResultsMsg = document.getElementById('no-results-message');
                if (noResultsMsg) {
                    noResultsMsg.style.display = 'none';
                }
            }
        }
		</script>
	</body>
</html>
