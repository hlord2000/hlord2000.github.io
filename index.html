<!DOCTYPE html>
<html lang="en">
<head>
	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-NME89B10ME"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-NME89B10ME');
	</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <title>nRF54L Pin Planner</title>
    <style>
        :root {
            --primary-color: #0066cc;
            --secondary-color: #e6f2ff;
            --border-color: #cccccc;
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            --disabled-color: #f1f1f1;
            --text-color: #333333;
            --light-text: #666666;
            --system-color: #8e44ad; /* Purple color for system/required components */
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .peripheral-selector {
            flex: 1;
            min-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }

        .chip-display {
            flex: 1;
            min-width: 600px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }

        .selected-peripherals {
            flex: 1;
            min-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }
        
        .simple-peripherals {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        .required-peripherals {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--system-color);
            border-radius: 5px;
            background-color: #f8f0ff;
        }
        
        .checkbox-group {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .checkbox-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            font-weight: 500;
            cursor: pointer;
        }
        
        .checkbox-label input {
            margin-right: 8px;
        }
        
        .checkbox-description {
            margin-top: 5px;
            margin-left: 24px;
            font-size: 0.9em;
            color: var(--light-text);
        }
        
        .system-peripheral {
            font-weight: 600;
            color: var(--system-color);
        }

        .peripheral-group {
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .peripheral-item {
            cursor: pointer;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .peripheral-item:hover {
            background-color: var(--secondary-color);
        }

        .peripheral-item.disabled {
            opacity: 0.5;
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }

        .peripheral-item.selected {
            background-color: var(--primary-color);
            color: white;
        }

        .chip-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            background-color: #e0e0e0;
            border-radius: 10px;
        }

        .pin {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #cccccc;
            border: 1px solid #999999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .pin:hover {
            transform: scale(1.2);
            z-index: 100;
        }

        .pin.used {
            background-color: var(--primary-color);
            color: white;
        }

        .pin.clock {
	    border: 2px solid var(--warning-color);
        }

        .pin.required {
            background-color: var(--error-color);
            color: white;
        }

        .pin.system {
            background-color: var(--system-color);
            color: white;
        }

        .pin.vdd, .pin.vss, .pin.debug {
            background-color: #999999;
            color: white;
        }

        .pin-details {
            margin: 20px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            min-height: 100px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px; /* Set a minimum height if needed */
        }

        .selected-list {
            list-style-type: none;
            padding: 0;
        }

        .selected-item {
            background-color: var(--secondary-color);
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .selected-item:hover {
            background-color: #d9e9ff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        
        .pin.highlighted {
            background-color: #ff9900;
            border-color: #ff6600;
            transform: scale(1.3);
            z-index: 200;
            box-shadow: 0 0 5px rgba(255, 153, 0, 0.7);
        }
        
        .selected-item:after {
            content: "✏️";
            position: absolute;
            top: 10px;
            right: 50px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .selected-item:hover:after {
            opacity: 1;
        }
        
        .selected-item.system {
            background-color: #f8f0ff;
            border-left: 3px solid var(--system-color);
        }
        
        .selected-item.highlighted {
            background-color: #fff0d9;
            border: 2px solid #ff9900;
            box-shadow: 0 0 8px rgba(255, 153, 0, 0.4);
        }

        .remove-btn {
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
        }

        .remove-btn:hover {
            opacity: 0.9;
        }
        
        .remove-btn.disabled {
            background-color: var(--disabled-color);
            color: var(--light-text);
            cursor: not-allowed;
        }

        .legend {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .button-group {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .button-group-vertical {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        
        .button-group-vertical button {
            width: 100%;
            margin: 0;
        }

        button {
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin: 0 2px;
            min-width: 120px;
        }

        button:hover {
            background-color: #0055aa;
        }

        button:disabled {
            background-color: var(--disabled-color);
            color: var(--light-text);
            cursor: not-allowed;
        }

        /* Pin positioning - Fixed for better alignment */
        .chip-container {
            position: relative;
            width: 420px;
            height: 420px;
            margin: 0 auto;
            background-color: #e0e0e0;
            border-radius: 10px;
        }

        .chip-body {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            width: 400px;
            height: 400px;
            background-color: #d0d0d0;
            border-radius: 5px;
        }

        .pin {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #cccccc;
            border: 1px solid #999999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        /* New CSS for vertical accordion menu */
        .accordion {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .accordion-item {
            border-bottom: 1px solid var(--border-color);
        }
        
        .accordion-item:last-child {
            border-bottom: none;
        }
        
        .accordion-header {
            background-color: #f1f1f1;
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .accordion-header:hover {
            background-color: #e0e0e0;
        }
        
        .accordion-header.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .accordion-content {
            display: none;
            padding: 15px;
            background-color: white;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .accordion-content.active {
            display: block;
        }
        
        .expand-icon {
            transition: transform 0.3s;
        }
        
        .accordion-header.active .expand-icon {
            transform: rotate(180deg);
        }
        
        /* Single-instance peripheral button */
        .single-peripheral-btn {
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 8px;
            padding: 10px 15px;
            background-color: #f1f1f1;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .single-peripheral-btn:hover {
            background-color: #e0e0e0;
        }
        
        .single-peripheral-btn.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .single-peripheral-btn.disabled {
            opacity: 0.5;
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }
        
        .peripherals-section {
            margin-bottom: 20px;
        }
        
        .peripherals-heading {
            margin-bottom: 10px;
            color: var(--primary-color);
            font-size: 1rem;
            font-weight: 600;
        }

        /* Modal for pin selection */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
        }

        .pin-selection-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .pin-selection-table th, 
        .pin-selection-table td {
            padding: 10px;
            border: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
        }

        .pin-selection-table th {
            background-color: #f5f5f5;
        }

        .pin-selection-table select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .pin-selection-table .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pin-selection-table .checkbox-option {
            display: flex;
            align-items: center;
        }

        .pin-selection-table .checkbox-option input {
            margin-right: 8px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        /* Import modal tabs */
        .import-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }
        
        .import-tab-btn {
            padding: 10px 15px;
            background-color: #f1f1f1;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            margin-right: 5px;
        }
        
        .import-tab-btn:hover {
            background-color: #e0e0e0;
        }
        
        .import-tab-btn.active {
            background-color: white;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .import-tab-content {
            display: none;
            padding: 15px 0;
        }
        
        .import-tab-content.active {
            display: block;
        }
        
        /* Package selection dropdown */
        .package-selector {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--secondary-color);
        }
        
        .package-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>nRF54L Pin Planner</h1>
            <p>Select peripherals and visualize pin assignments for your nRF54L</p>
				<p style="text-align: center; margin-top: 10px; font-size: 0.9em;">
							<a href="http://github.com/hlord2000/hlord2000.github.io" target="_blank" style="text-decoration: none; color: var(--primary-color);">
								<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Icon" style="height: 1em; vertical-align: middle; margin-right: 5px;">
                    View Source on GitHub
                </a>
            </p>
            <div style="background-color: #fff3cd; color: #856404; padding: 10px; border: 1px solid #ffeeba; border-radius: 5px; margin-top: 10px; font-weight: bold; text-align: center;">
                NOT an official Nordic application. Please double check all configurations with the nRF54L documentation available here: 
                <a href="https://docs.nordicsemi.com/category/nrf-54L-series" target="_blank">https://docs.nordicsemi.com/category/nrf-54L-series</a>
            </div>
        </div>
        
        <!-- Package Selection Dropdown -->
        <div class="package-selector">
            <h3>Package Selection</h3>
            <select id="packageSelector">
                <option value="QFN-48" selected>QFN-48</option>
                <option value="WLCSP" disabled>WLCSP (Coming Soon)</option>
            </select>
        </div>

        <div class="flex-container">
            <div class="peripheral-selector">
                <h2>Available Peripherals</h2>
                <input type="text" id="searchPeripherals" class="search-box" placeholder="Search peripherals...">
                
                <!-- Optional Simple Peripherals Section -->
                <div class="simple-peripherals">
                    <h3>Pin Specific Peripherals</h3>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="xl1xl2-checkbox"> 
                            <span>32.768 kHz Crystal (XL1/XL2)</span>
                        </label>
                        <div class="checkbox-description">Uses P1.00 and P1.01 for low-frequency crystal</div>
                    </div>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="nfc-checkbox"> 
                            <span>NFC Antenna (NFC1/NFC2)</span>
                        </label>
                        <div class="checkbox-description">Uses P1.02 and P1.03 for NFC antenna</div>
                    </div>
                </div>
                
                <!-- Single-instance peripherals section -->
                <div class="peripherals-section">
                    <div class="peripherals-heading">Single-Instance Peripherals</div>
                    <div id="single-peripherals-container">
                        <!-- Will be filled dynamically -->
                    </div>
                </div>
                
                <!-- Multiple-instance peripherals accordion section -->
                <div class="peripherals-section">
                    <div class="peripherals-heading">Multiple-Instance Peripherals</div>
                    <div class="accordion" id="peripheralAccordion">
                        <!-- Will be filled dynamically with multi-instance peripherals -->
                    </div>
                </div>
            </div>

            <div class="chip-display">
                <h2 id="chipTitleDisplay">QFN-48 Pin Layout</h2>
                <div class="chip-container">
                    <div class="left-pins"></div>
                    <div class="right-pins"></div>
                    <div class="top-pins"></div>
                    <div class="bottom-pins"></div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #cccccc;"></div>
                        <span>Available</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--primary-color);"></div>
                        <span>Used</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--warning-color);"></div>
                        <span>Clock Pin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--error-color);"></div>
                        <span>Required</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--system-color);"></div>
                        <span>System</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #999999;"></div>
                        <span>Power/Debug</span>
                    </div>
                </div>
                <div class="pin-details" id="pinDetails">
                    <p>Click a pin to see details...</p>
                </div>
            </div>

            <div class="selected-peripherals">
                <h2>Selected Peripherals</h2>
                <ul class="selected-list" id="selectedList">
                    <li class="empty-message">No peripherals selected yet.</li>
                </ul>
                <div class="button-group-vertical">
                    <button id="clearAllBtn">Clear All</button>
                    <button id="exportBtn">Export Configuration</button>
                    <button id="importBtn">Import Configuration</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Import Configuration Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Import Configuration</h2>
                <span class="close" id="closeImportModal">&times;</span>
            </div>
            <div id="importModalBody">
                <div class="import-tabs">
                    <button class="import-tab-btn active" data-tab="file-upload">File Upload</button>
                    <button class="import-tab-btn" data-tab="paste-json">Paste JSON</button>
                </div>
                
                <div class="import-tab-content active" id="file-upload">
                    <p>Select a JSON configuration file to import:</p>
                    <input type="file" id="importFileInput" accept=".json" style="margin-bottom: 15px;">
                </div>
                
                <div class="import-tab-content" id="paste-json">
                    <p>Paste your exported JSON configuration below:</p>
                    <textarea id="importJsonInput" style="width: 100%; height: 200px; margin-bottom: 15px; font-family: monospace;"></textarea>
                </div>
                
                <div id="importError" style="color: red; margin-bottom: 10px; display: none;"></div>
            </div>
            <div class="modal-footer">
                <button id="cancelImport">Cancel</button>
                <button id="confirmImport">Import</button>
            </div>
        </div>
    </div>
    
    <!-- Pin Selection Modal -->
    <div id="pinSelectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Select Pins for Peripheral</h2>
                <span class="close">&times;</span>
            </div>
            <div id="modalBody">
                <p>Select which pins to use for each peripheral function:</p>
                <div id="pinRestrictionWarning" style="display: none; background-color: #fff3cd; color: #856404; padding: 10px; margin-bottom: 15px; border: 1px solid #ffeeba; border-radius: 5px;">
                    <strong>Note:</strong> This peripheral supports both Port 1 and specific Port 2 pins. For optimal power consumption, Port 1 is recommended. If using Port 2, only the specifically designated P2 pins for this peripheral can be used.
                </div>
                <table class="pin-selection-table" id="pinSelectionTable">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Required</th>
                            <th>Pin Selection</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody id="pinSelectionTableBody">
                        <!-- Will be filled dynamically -->
                    </tbody>
                </table>
            </div>
            <div class="modal-footer">
                <button id="cancelPinSelection">Cancel</button>
                <button id="confirmPinSelection">Confirm Selection</button>
            </div>
        </div>
    </div>
    
    <script>
        // Data structures
        const peripherals = {
            "SPI": [
                { id: "SPIM/SPIS00", port: "Port 2", pins: "Dedicated pins only (P2.00, P2.01, P2.02, P2.04, P2.05)", notes: "SCLK requires clock pin; 32MHz requires high drive low and high", address: "0x5004A000" },
                { id: "SPIM/SPIS20", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2.00, P2.01, P2.02, P2.04, P2.05)", notes: "SCLK requires clock pin", address: "0x500C6000" },
                { id: "SPIM/SPIS21", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2.06, P2.07, P2.08, P2.09, P2.10)", notes: "SCLK requires clock pin", address: "0x500C7000" },
                { id: "SPIM/SPIS22", port: "Port 1", pins: "Any pins (P1)", notes: "SCLK requires clock pin", address: "0x500C8000" },
                { id: "SPIM/SPIS30", port: "Port 0", pins: "Any pins", notes: "SCLK requires clock pin", address: "0x50104000" }
            ],
            "TAMPC": [
                { id: "TAMPC", port: "Port 1", pins: "Specific pin pairs", notes: "Active shield pairs must be used together", address: "0x500D8000" }
            ],
            "I2C": [
                { id: "TWIM/TWIS20", port: "Port 1", pins: "Any pins (P1)", notes: "SCL requires clock pin", address: "0x500C6000" },
                { id: "TWIM/TWIS21", port: "Port 1", pins: "Any pins (P1)", notes: "SCL requires clock pin", address: "0x500C7000" },
                { id: "TWIM/TWIS22", port: "Port 1", pins: "Any pins (P1)", notes: "SCL requires clock pin", address: "0x500C8000" },
                { id: "TWIM/TWIS30", port: "Port 0", pins: "Any pins", notes: "SCL requires clock pin", address: "0x50104000" }
            ],
            "UART": [
                { id: "UARTE00", port: "Port 2", pins: "Any pins", notes: "", address: "0x5004A000" },
                { id: "UARTE20", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2.00, P2.02, P2.04, P2.05)", notes: "", address: "0x500C6000" },
                { id: "UARTE21", port: "Port 1 or Port 2", pins: "Any pins (P1) or dedicated pins (P2.07, P2.08, P2.09, P2.10)", notes: "", address: "0x500C7000" },
                { id: "UARTE22", port: "Port 1", pins: "Any pins (P1)", notes: "", address: "0x500C8000" },
                { id: "UARTE30", port: "Port 0", pins: "Any pins", notes: "", address: "0x50104000" }
            ],
            "Others": [
                { id: "PDM20", port: "Port 1", pins: "Any pins", notes: "CLK requires clock pin", address: "0x500D0000" },
                { id: "PDM21", port: "Port 1", pins: "Any pins", notes: "CLK requires clock pin", address: "0x500D1000" },
                { id: "PWM20", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D2000" },
                { id: "PWM21", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D3000" },
                { id: "PWM22", port: "Port 1", pins: "Any pins", notes: "", address: "0x500D4000" },
                { id: "I2S20", port: "Port 1", pins: "Any pins", notes: "MCK and SCK require clock pin", address: "0x500DD000" },
                // Removed NFCT from here as it's handled separately in checkboxes
                { id: "SAADC", port: "Port 1", pins: "P1.04, P1.05, P1.06, P1.07, P1.11, P1.12, P1.13, P1.14", notes: "Specific pins only", address: "0x500D5000" },
                { id: "GPIOTE20", port: "Port 1", pins: "Any pins", notes: "8 channels, applies to P1 pins only", address: "0x500DA000", channels: 8 },
                { id: "GPIOTE30", port: "Port 0", pins: "Any pins", notes: "4 channels, applies to P0 pins only", address: "0x5010C000", channels: 4 },
                { id: "GRTC", port: "Mixed", pins: "(CLKOUT32K/GRTCLFCLKOUT, P0.04), (PWMOUT/GRTCPWM, P0.03), (CLK16M, P1.08)", notes: "Specific pin assignments", address: "0x500E2000" },
                { id: "QDEC20", port: "Port 1", pins: "Any pins", notes: "", address: "0x500E0000" },
                { id: "QDEC21", port: "Port 1", pins: "Any pins", notes: "", address: "0x500E1000" }
            ],
            "RADIO": [
                { id: "RADIO", port: "Port 1", pins: "P1.05, P1.09, P1.10, P1.11, P1.12, P1.13, P1.14", notes: "Direction Finding pins for Bluetooth", address: "0x50010000" }
            ],
            "TRACE": [
                { id: "TRACE", port: "Port 2", pins: "P2.06, P2.07, P2.08, P2.09, P2.10", notes: "Debug trace interface", address: "0x50008000" }
            ]
        };

        // Pin data: number, pin name, is it a clock pin, special function
        const pinData = [
            { number: 1, name: "P1.00", isClock: false, port: "P1", index: 0, type: "io", functions: ["XL1", "Digital I/O", "Analog input"] },
            { number: 2, name: "P1.01", isClock: false, port: "P1", index: 1, type: "io", functions: ["XL2", "Digital I/O", "Analog input"] },
            { number: 3, name: "P1.02", isClock: false, port: "P1", index: 2, type: "io", functions: ["NFC1", "Digital I/O", "NFC input"] },
            { number: 4, name: "P1.03", isClock: true, port: "P1", index: 3, type: "io", functions: ["NFC2", "Digital I/O", "NFC input"] },
            { number: 5, name: "P1.04", isClock: true, port: "P1", index: 4, type: "io", functions: ["ASO[0]", "AIN0", "Digital I/O", "TAMPC active shield 0 output", "Analog input"] },
            { number: 6, name: "P1.05", isClock: false, port: "P1", index: 5, type: "io", functions: ["ASI[0]", "RADIO[6]", "AIN1", "Digital I/O", "TAMPC active shield 0 input", "Analog input"] },
            { number: 7, name: "P1.06", isClock: false, port: "P1", index: 6, type: "io", functions: ["ASO[1]", "AIN2", "Digital I/O", "TAMPC active shield 1 output", "Analog input"] },
            { number: 8, name: "P1.07", isClock: false, port: "P1", index: 7, type: "io", functions: ["ASI[1]", "AIN3", "Digital I/O", "TAMPC active shield 1 input", "Analog input"] },
            { number: 9, name: "P1.08", isClock: true, port: "P1", index: 8, type: "io", functions: ["CLK16M", "EXTREF", "Digital I/O", "GRTC HF clock output", "External reference for SAADC"] },
            { number: 10, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 11, name: "P2.00", isClock: false, port: "P2", index: 0, type: "io", functions: ["Digital I/O", "SPIM DCX", "UARTE RXD", "QSPI D3"] },
            { number: 12, name: "P2.01", isClock: true, port: "P2", index: 1, type: "io", functions: ["Digital I/O", "SPIM SCK", "SPIS SCK", "QSPI SCK"] },
            { number: 13, name: "P2.02", isClock: false, port: "P2", index: 2, type: "io", functions: ["Digital I/O", "SPIM SDO", "SPIS SDO", "UARTE TXD", "QSPI D0", "Serial wire output (SWO)"] },
            { number: 14, name: "P2.03", isClock: false, port: "P2", index: 3, type: "io", functions: ["Digital I/O", "QSPI D2"] },
            { number: 15, name: "P2.04", isClock: false, port: "P2", index: 4, type: "io", functions: ["Digital I/O", "SPIM SDI", "SPIS SDI", "UARTE CTS", "QSPI D1"] },
            { number: 16, name: "P2.05", isClock: false, port: "P2", index: 5, type: "io", functions: ["Digital I/O", "SPIM CS", "UARTE RTS", "QSPI CS"] },
            { number: 17, name: "P2.06", isClock: true, port: "P2", index: 6, type: "io", functions: ["TRACECLK", "Digital I/O", "SPIM SCK", "SPIS SCK", "Trace clock"] },
            { number: 18, name: "P2.07", isClock: false, port: "P2", index: 7, type: "io", functions: ["TRACEDATA[0]", "SWO", "Digital I/O", "Trace data", "Serial wire output (SWO)", "SPIM DCX", "UARTE RXD"] },
            { number: 19, name: "P2.08", isClock: false, port: "P2", index: 8, type: "io", functions: ["TRACEDATA[1]", "Digital I/O", "Trace data", "SPIM SDO", "SPIS SDO", "UARTE TXD"] },
            { number: 20, name: "P2.09", isClock: false, port: "P2", index: 9, type: "io", functions: ["TRACEDATA[2]", "Digital I/O", "Trace data", "SPIM SDI", "SPIS SDI", "UARTE CTS"] },
            { number: 21, name: "P2.10", isClock: false, port: "P2", index: 10, type: "io", functions: ["TRACEDATA[3]", "Digital I/O", "Trace data", "SPIM CS", "UARTE RTS"] },
            { number: 22, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 23, name: "P0.00", isClock: false, port: "P0", index: 0, type: "io", functions: ["Digital I/O"] },
            { number: 24, name: "P0.01", isClock: false, port: "P0", index: 1, type: "io", functions: ["Digital I/O"] },
            { number: 25, name: "SWDIO", isClock: false, port: null, index: null, type: "debug", functions: ["Serial wire data. Bidirectional with standard-drive and on-chip pull-down."] },
            { number: 26, name: "SWDCLK", isClock: false, port: null, index: null, type: "debug", functions: ["Serial wire clock. Input with on-chip pull-up."] },
            { number: 27, name: "P0.02", isClock: false, port: "P0", index: 2, type: "io", functions: ["Digital I/O"] },
            { number: 28, name: "P0.03", isClock: true, port: "P0", index: 3, type: "io", functions: ["GRTCPWM", "Digital I/O", "GRTC PWM output"] },
            { number: 29, name: "P0.04", isClock: true, port: "P0", index: 4, type: "io", functions: ["GRTCLFCLKOUT", "Digital I/O", "GRTC LF clock output"] },
            { number: 30, name: "nRESET", isClock: false, port: null, index: null, type: "reset", functions: ["Pin reset with on-chip pull-up"] },
            { number: 31, name: "ANT", isClock: false, port: null, index: null, type: "rf", functions: ["Single ended radio antenna connection"] },
            { number: 32, name: "VSS_PA", isClock: false, port: null, index: null, type: "vss", functions: ["Ground (radio supply)"] },
            { number: 33, name: "DECRF", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 34, name: "XC1", isClock: false, port: null, index: null, type: "crystal", functions: ["Connection for 32 MHz crystal"] },
            { number: 35, name: "XC2", isClock: false, port: null, index: null, type: "crystal", functions: ["Connection for 32 MHz crystal"] },
            { number: 36, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 37, name: "P1.09", isClock: false, port: "P1", index: 9, type: "io", functions: ["ASO[2]", "RADIO[0]", "Digital I/O", "TAMPC active shield 2 output", "RADIO DFEGPIO"] },
            { number: 38, name: "P1.10", isClock: false, port: "P1", index: 10, type: "io", functions: ["ASI[2]", "RADIO[1]", "Digital I/O", "TAMPC active shield 2 input", "RADIO DFEGPIO"] },
            { number: 39, name: "P1.11", isClock: true, port: "P1", index: 11, type: "io", functions: ["ASO[3]", "RADIO[2]", "AIN4", "Digital I/O", "TAMPC active shield 3 output", "RADIO DFEGPIO", "Analog input"] },
            { number: 40, name: "P1.12", isClock: true, port: "P1", index: 12, type: "io", functions: ["ASI[3]", "RADIO[3]", "AIN5", "Digital I/O", "TAMPC active shield 3 input", "RADIO DFEGPIO", "Analog input"] },
            { number: 41, name: "P1.13", isClock: false, port: "P1", index: 13, type: "io", functions: ["RADIO[4]", "AIN6", "Digital I/O", "RADIO DFEGPIO", "Analog input"] },
            { number: 42, name: "P1.14", isClock: false, port: "P1", index: 14, type: "io", functions: ["RADIO[5]", "AIN7", "Digital I/O", "RADIO DFEGPIO", "Analog input"] },
            { number: 43, name: "DECA", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 44, name: "VSS", isClock: false, port: null, index: null, type: "vss", functions: ["Ground"] },
            { number: 45, name: "DECD", isClock: false, port: null, index: null, type: "power", functions: ["0.9 V regulator supply decoupling"] },
            { number: 46, name: "DCC", isClock: false, port: null, index: null, type: "power", functions: ["DC/DC regulator output"] },
            { number: 47, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] },
            { number: 48, name: "VDD", isClock: false, port: null, index: null, type: "vdd", functions: ["Power supply"] }
        ];

        // Define peripheral functions required for each peripheral type
        const peripheralFunctions = {
            "SPI": [
                { name: "SPIM SCK", description: "SPI Clock", required: true, requiresClock: true },
                { name: "SPIM SDO", description: "SPI MOSI (Master Out, Slave In)", required: true, requiresClock: false },
                { name: "SPIM SDI", description: "SPI MISO (Master In, Slave Out)", required: true, requiresClock: false },
                { name: "SPIM CS", description: "SPI Chip Select", required: true, requiresClock: false },
                { name: "SPIM DCX", description: "SPI Data/Command", required: false, requiresClock: false }
            ],
            "TAMPC": [
                { name: "Shield Pair 0", description: "Active Shield 0 (ASO[0]/ASI[0])", required: false, isPair: true, 
                  outputPin: "P1.04", inputPin: "P1.05", outputFunc: "ASO[0]", inputFunc: "ASI[0]" },
                { name: "Shield Pair 1", description: "Active Shield 1 (ASO[1]/ASI[1])", required: false, isPair: true, 
                  outputPin: "P1.06", inputPin: "P1.07", outputFunc: "ASO[1]", inputFunc: "ASI[1]" },
                { name: "Shield Pair 2", description: "Active Shield 2 (ASO[2]/ASI[2])", required: false, isPair: true, 
                  outputPin: "P1.09", inputPin: "P1.10", outputFunc: "ASO[2]", inputFunc: "ASI[2]" },
                { name: "Shield Pair 3", description: "Active Shield 3 (ASO[3]/ASI[3])", required: false, isPair: true, 
                  outputPin: "P1.11", inputPin: "P1.12", outputFunc: "ASO[3]", inputFunc: "ASI[3]" }
            ],
            "I2C": [
                { name: "TWIM SCL", description: "I2C Serial Clock Line", required: true, requiresClock: true },
                { name: "TWIM SDA", description: "I2C Serial Data Line", required: true, requiresClock: false }
            ],
            "UART": [
                { name: "UARTE TXD", description: "UART Transmit Data", required: true, requiresClock: false },
                { name: "UARTE RXD", description: "UART Receive Data", required: true, requiresClock: false },
                { name: "UARTE CTS", description: "UART Clear To Send", required: false, requiresClock: false },
                { name: "UARTE RTS", description: "UART Request To Send", required: false, requiresClock: false }
            ],
            "PDM": [
                { name: "PDM CLK", description: "PDM Clock", required: true, requiresClock: true },
                { name: "PDM DIN", description: "PDM Data In", required: true, requiresClock: false }
            ],
            "PWM": [
                { name: "PWM OUT0", description: "PWM Output 0", required: true, requiresClock: false },
                { name: "PWM OUT1", description: "PWM Output 1", required: false, requiresClock: false },
                { name: "PWM OUT2", description: "PWM Output 2", required: false, requiresClock: false },
                { name: "PWM OUT3", description: "PWM Output 3", required: false, requiresClock: false }
            ],
            "I2S": [
                { name: "I2S SCK", description: "I2S Serial Clock", required: true, requiresClock: true },
                { name: "I2S LRCK", description: "I2S Left/Right Clock", required: true, requiresClock: false },
                { name: "I2S SDIN", description: "I2S Serial Data In", required: true, requiresClock: false },
                { name: "I2S SDOUT", description: "I2S Serial Data Out", required: false, requiresClock: false },
                { name: "I2S MCK", description: "I2S Master Clock", required: false, requiresClock: true }
            ],
            "QDEC": [
                { name: "QDEC A", description: "Quadrature Decoder A Input", required: true, requiresClock: false },
                { name: "QDEC B", description: "Quadrature Decoder B Input", required: true, requiresClock: false },
                { name: "QDEC LED", description: "Quadrature Decoder LED Output", required: false, requiresClock: false }
            ],
            "NFCT": [
                { name: "NFC1", description: "NFC Pin 1", required: true, requiresClock: false, specificPin: "P1.02" },
                { name: "NFC2", description: "NFC Pin 2", required: true, requiresClock: false, specificPin: "P1.03" }
            ],
            "SAADC": [
                { name: "AIN0", description: "Analog Input 0", required: false, requiresClock: false, specificPin: "P1.04" },
                { name: "AIN1", description: "Analog Input 1", required: false, requiresClock: false, specificPin: "P1.05" },
                { name: "AIN2", description: "Analog Input 2", required: false, requiresClock: false, specificPin: "P1.06" },
                { name: "AIN3", description: "Analog Input 3", required: false, requiresClock: false, specificPin: "P1.07" },
                { name: "AIN4", description: "Analog Input 4", required: false, requiresClock: false, specificPin: "P1.11" },
                { name: "AIN5", description: "Analog Input 5", required: false, requiresClock: false, specificPin: "P1.12" },
                { name: "AIN6", description: "Analog Input 6", required: false, requiresClock: false, specificPin: "P1.13" },
                { name: "AIN7", description: "Analog Input 7", required: false, requiresClock: false, specificPin: "P1.14" }
            ],
            "GRTC": [
                { name: "GRTCPWM", description: "GRTC PWM Output", required: false, requiresClock: false, specificPin: "P0.03" },
                { name: "GRTCLFCLKOUT", description: "GRTC LF Clock Output", required: false, requiresClock: true, specificPin: "P0.04" },
                { name: "CLK16M", description: "GRTC HF Clock Output", required: false, requiresClock: true, specificPin: "P1.08" }
            ],
            // Updated GPIOTE functions to support multiple channels
            "GPIOTE20": [
                { name: "GPIOTE PIN-0", description: "GPIOTE Channel 0", required: false, requiresClock: false, channel: 0 },
                { name: "GPIOTE PIN-1", description: "GPIOTE Channel 1", required: false, requiresClock: false, channel: 1 },
                { name: "GPIOTE PIN-2", description: "GPIOTE Channel 2", required: false, requiresClock: false, channel: 2 },
                { name: "GPIOTE PIN-3", description: "GPIOTE Channel 3", required: false, requiresClock: false, channel: 3 },
                { name: "GPIOTE PIN-4", description: "GPIOTE Channel 4", required: false, requiresClock: false, channel: 4 },
                { name: "GPIOTE PIN-5", description: "GPIOTE Channel 5", required: false, requiresClock: false, channel: 5 },
                { name: "GPIOTE PIN-6", description: "GPIOTE Channel 6", required: false, requiresClock: false, channel: 6 },
                { name: "GPIOTE PIN-7", description: "GPIOTE Channel 7", required: false, requiresClock: false, channel: 7 }
            ],
            "GPIOTE30": [
                { name: "GPIOTE PIN-0", description: "GPIOTE Channel 0", required: false, requiresClock: false, channel: 0 },
                { name: "GPIOTE PIN-1", description: "GPIOTE Channel 1", required: false, requiresClock: false, channel: 1 },
                { name: "GPIOTE PIN-2", description: "GPIOTE Channel 2", required: false, requiresClock: false, channel: 2 },
                { name: "GPIOTE PIN-3", description: "GPIOTE Channel 3", required: false, requiresClock: false, channel: 3 }
            ],
            "RADIO": [
                { name: "RADIO[0]", description: "Direction Finding GPIO 0", required: false, requiresClock: false, specificPin: "P1.09" },
                { name: "RADIO[1]", description: "Direction Finding GPIO 1", required: false, requiresClock: false, specificPin: "P1.10" },
                { name: "RADIO[2]", description: "Direction Finding GPIO 2", required: false, requiresClock: false, specificPin: "P1.11" },
                { name: "RADIO[3]", description: "Direction Finding GPIO 3", required: false, requiresClock: false, specificPin: "P1.12" },
                { name: "RADIO[4]", description: "Direction Finding GPIO 4", required: false, requiresClock: false, specificPin: "P1.13" },
                { name: "RADIO[5]", description: "Direction Finding GPIO 5", required: false, requiresClock: false, specificPin: "P1.14" },
                { name: "RADIO[6]", description: "Direction Finding GPIO 6", required: false, requiresClock: false, specificPin: "P1.05" }
            ],
            "TRACE": [
                { name: "TRACECLK", description: "Trace Clock", required: true, requiresClock: true, specificPin: "P2.06" },
                { name: "TRACEDATA[0]", description: "Trace Data 0", required: true, requiresClock: false, specificPin: "P2.07" },
                { name: "TRACEDATA[1]", description: "Trace Data 1", required: false, requiresClock: false, specificPin: "P2.08" },
                { name: "TRACEDATA[2]", description: "Trace Data 2", required: false, requiresClock: false, specificPin: "P2.09" },
                { name: "TRACEDATA[3]", description: "Trace Data 3", required: false, requiresClock: false, specificPin: "P2.10" }
            ]
        };
        
        // Global state
        let selectedPeripherals = [];
        let usedPins = {};
        let usedAddresses = {}; // Track used address spaces
        let currentPeripheral = null;
        let currentCategory = null;
        let tempSelectedPins = {}; // Used for storing pin selections temporarily during modal dialog
        let currentPackage = "QFN-48"; // Default package
        let p2PeripheralPinRestrictions = {
            // SPI peripherals
            "SPIM/SPIS00": {
                "P2.00": "SPIM DCX",
                "P2.07": "SPIM DCX",
                "P2.01": "SPIM SCK",
                "P2.06": "SPIM SCK",
                "P2.02": "SPIM SDO",
                "P2.08": "SPIM SDO",
                "P2.04": "SPIM SDI",
                "P2.09": "SPIM SDI",
                "P2.05": "SPIM CS",
                "P2.10": "SPIM CS"
            },
            "SPIM/SPIS20": {
                "P2.00": "SPIM DCX",
                "P2.01": "SPIM SCK",
                "P2.02": "SPIM SDO",
                "P2.04": "SPIM SDI",
                "P2.05": "SPIM CS"
            },
            "SPIM/SPIS21": {
                "P2.06": "SPIM SCK",
                "P2.07": "SPIM DCX",
                "P2.08": "SPIM SDO",
                "P2.09": "SPIM SDI",
                "P2.10": "SPIM CS"
            },
            // UART peripherals
            "UARTE00": {
                "P2.00": "UARTE RXD",
                "P2.07": "UARTE RXD",
                "P2.02": "UARTE TXD",
                "P2.08": "UARTE TXD",
                "P2.04": "UARTE CTS",
                "P2.09": "UARTE CTS",
                "P2.05": "UARTE RTS",
                "P2.10": "UARTE RTS"
            },
            "UARTE20": {
                "P2.00": "UARTE RXD",
                "P2.02": "UARTE TXD",
                "P2.04": "UARTE CTS",
                "P2.05": "UARTE RTS"
            },
            "UARTE21": {
                "P2.07": "UARTE RXD",
                "P2.08": "UARTE TXD",
                "P2.09": "UARTE CTS",
                "P2.10": "UARTE RTS"
            }
        };
        
        // Helper function to check if a peripheral has an address conflict with already selected peripherals
        function hasAddressConflict(peripheral) {
            // If peripheral has no address, it can't conflict
            if (!peripheral.address) return false;
            
            // Check if this address is already in use
            return !!usedAddresses[peripheral.address];
        }
        
        // Helper function to check if a peripheral has P2 pin restrictions
        function hasP2PinRestrictions(peripheral) {
            return !!p2PeripheralPinRestrictions[peripheral.id];
        }
        
        // Helper function to get the restricted P2 pins for a peripheral
        function getRestrictedP2Pins(peripheral) {
            return p2PeripheralPinRestrictions[peripheral.id] || {};
        }
        
        // Helper function to check if a pin selection is valid for a peripheral with P2 restrictions
        function isValidPinSelectionForP2Peripheral(peripheral, pinSelections) {
            // If this peripheral doesn't have P2 restrictions, any selection is valid
            if (!hasP2PinRestrictions(peripheral)) {
                return true;
            }
            
            // Get all selected pins
            const selectedPins = Object.keys(pinSelections);
            
            // Check if any pins are selected
            if (selectedPins.length === 0) {
                return true; // No pins selected yet, so no conflict
            }
            
            // Check if we're using P2 pins
            const usingP2Pins = selectedPins.some(pin => pin.startsWith('P2.'));
            
            // Check if we're using P1 pins
            const usingP1Pins = selectedPins.some(pin => pin.startsWith('P1.'));
            
            // Cannot mix P1 and P2 pins for these peripherals
            if (usingP1Pins && usingP2Pins) {
                return false;
            }
            
            // If using P2 pins, they must match the restrictions
            if (usingP2Pins) {
                const restrictedPins = getRestrictedP2Pins(peripheral);
                
                // Check if each selected P2 pin is in the restricted list with the correct function
                for (const [pin, func] of Object.entries(pinSelections)) {
                    if (pin.startsWith('P2.')) {
                        // If this P2 pin is not in the restricted list or has the wrong function, it's invalid
                        if (!restrictedPins[pin] || !func.includes(restrictedPins[pin])) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Helper function to get peripheral functions based on category and peripheral
        function getPeripheralFunctions(category, peripheral) {
            // For most peripherals, we can use the base name to look up functions
            let baseName = peripheral.id.replace(/\d+$/, '');
            
            // Special cases for peripherals with different naming patterns
            if (baseName.includes('SPIM/SPIS')) {
                baseName = 'SPI';
            } else if (baseName.includes('TWIM/TWIS')) {
                baseName = 'I2C';
            } else if (baseName.includes('UARTE')) {
                baseName = 'UART';
            } else if (baseName.includes('PDM')) {
                baseName = 'PDM';
            } else if (baseName.includes('PWM')) {
                baseName = 'PWM';
            } else if (baseName.includes('I2S')) {
                baseName = 'I2S';
            } else if (baseName.includes('QDEC')) {
                baseName = 'QDEC';
            } else if (baseName.includes('NFCT')) {
                baseName = 'NFCT';
            }
            
            // Return the functions for this peripheral type
            return peripheralFunctions[baseName] || [];
        }
        
        // Helper function to check if a function is required
        function isRequiredFunction(category, functionName) {
            // Get the base category name
            let baseName = category;
            if (category.includes('SPI')) {
                baseName = 'SPI';
            } else if (category.includes('I2C') || category.includes('TWIM')) {
                baseName = 'I2C';
            } else if (category.includes('UART')) {
                baseName = 'UART';
            }
            
            // Look up the function in the peripheralFunctions
            const functions = peripheralFunctions[baseName] || [];
            const func = functions.find(f => f.name === functionName);
            
            // Return whether the function is required
            return func ? !!func.required : false;
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing nRF54L Pin Planner...");
            
            // Organize peripherals into single and multi-instance categories
            organizePeripherals();
            
            // Create pin layout
            createPinLayout();
            
            // Set up event listeners
            document.getElementById('clearAllBtn').addEventListener('click', clearAllPeripherals);
            document.getElementById('exportBtn').addEventListener('click', exportConfiguration);
            document.getElementById('importBtn').addEventListener('click', openImportModal);
            document.getElementById('searchPeripherals').addEventListener('input', filterPeripherals);
            
            // Simple peripherals checkboxes
            document.getElementById('xl1xl2-checkbox').addEventListener('change', toggleXL1XL2);
            document.getElementById('nfc-checkbox').addEventListener('change', toggleNFC);
            
            // Modal event listeners
            document.querySelector('#pinSelectionModal .close').addEventListener('click', closePinSelectionModal);
            document.getElementById('closeImportModal').addEventListener('click', closeImportModal);
            document.getElementById('cancelPinSelection').addEventListener('click', closePinSelectionModal);
            document.getElementById('confirmPinSelection').addEventListener('click', confirmPinSelection);
            document.getElementById('cancelImport').addEventListener('click', closeImportModal);
            document.getElementById('confirmImport').addEventListener('click', importConfiguration);
            
            // Import tab switching
            document.querySelectorAll('.import-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all tabs
                    document.querySelectorAll('.import-tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.import-tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.dataset.tab;
                    document.getElementById(tabId).classList.add('active');
                    
                    // Clear error message when switching tabs
                    document.getElementById('importError').style.display = 'none';
                });
            });
            
            // Package selection
            document.getElementById('packageSelector').addEventListener('change', handlePackageChange);
            
            // Set HF Crystal pins as system requirement (always on)
            setHFXtalAsSystemRequirement();
            
            // Log that initialization is complete
            console.log("Initialization complete. Peripherals loaded:", 
                Object.keys(peripherals).map(cat => `${cat}: ${peripherals[cat].length}`));
        });
        
        // Organize peripherals into single and multi-instance categories
        function organizePeripherals() {
            // Helper function to get the base name of a peripheral (without number)
            function getBaseName(id) {
                return id.replace(/\d+$/, '');
            }
            
            // Create maps to track instances of peripherals by base name
            const peripheralCounts = {};
            const peripheralsByBase = {};
            
            // Count instances of each peripheral by base name
            for (const category in peripherals) {
                peripherals[category].forEach(peripheral => {
                    // Extract base name (remove trailing numbers)
                    let baseName = getBaseName(peripheral.id);
                    
                    // Special case for SPI because the naming is inconsistent
                    if (baseName.includes('SPIM/SPIS')) {
                        baseName = 'SPIM/SPIS';
                    }
                    
                    // Initialize counters if needed
                    if (!peripheralCounts[baseName]) {
                        peripheralCounts[baseName] = 0;
                        peripheralsByBase[baseName] = [];
                    }
                    
                    // Count this instance
                    peripheralCounts[baseName]++;
                    
                    // Store this peripheral with its category
                    peripheralsByBase[baseName].push({ peripheral, category });
                });
            }
            
            // Clear containers
            const singleContainer = document.getElementById('single-peripherals-container');
            const accordionContainer = document.getElementById('peripheralAccordion');
            singleContainer.innerHTML = '';
            accordionContainer.innerHTML = '';
            
            // Process single-instance peripherals
            for (const baseName in peripheralCounts) {
                if (peripheralCounts[baseName] === 1) {
                    // Single instance - add as button
                    const peripheral = peripheralsByBase[baseName][0].peripheral;
                    const category = peripheralsByBase[baseName][0].category;
                    
                    const btn = document.createElement('button');
                    btn.className = 'single-peripheral-btn';
                    btn.dataset.id = peripheral.id;
                    btn.dataset.category = category;
                    btn.textContent = `${peripheral.id} (${peripheral.port})`;
                    
                    btn.addEventListener('click', function() {
                        // Check if peripheral is already selected - allow editing if it is
                        const isSelected = this.classList.contains('selected');
                        if (isSelected) {
                            // Open for editing
                            editPeripheral(peripheral.id);
                        } else {
                            // Check for address conflicts
                            if (hasAddressConflict(peripheral)) {
                                alert(`Cannot select ${peripheral.id} because it shares the same address space (${peripheral.address}) with another selected peripheral.`);
                                return;
                            }
                            openPinSelectionModal(peripheral, category);
                        }
                    });
                    
                    singleContainer.appendChild(btn);
                } else {
                    // Multiple instances - add as accordion item
                    const accordionItem = document.createElement('div');
                    accordionItem.className = 'accordion-item';
                    
                    const header = document.createElement('div');
                    header.className = 'accordion-header';
                    header.dataset.target = `${baseName.replace(/[^a-zA-Z0-9]/g, '')}-content`;
                    
                    header.innerHTML = `
                        <span>${baseName}</span>
                        <span class="expand-icon">▼</span>
                    `;
                    
                    const content = document.createElement('div');
                    content.className = 'accordion-content';
                    content.id = `${baseName.replace(/[^a-zA-Z0-9]/g, '')}-content`;
                    
                    // Add all instances to the content
                    peripheralsByBase[baseName].forEach(item => {
                        const peripheralItem = document.createElement('div');
                        peripheralItem.className = 'peripheral-item';
                        peripheralItem.dataset.id = item.peripheral.id;
                        peripheralItem.dataset.category = item.category;
                        
                        peripheralItem.innerHTML = `
                            <span>${item.peripheral.id}</span>
                            <span>${item.peripheral.port}</span>
                        `;
                        
                        peripheralItem.addEventListener('click', function() {
                            if (this.classList.contains('selected')) {
                                // If already selected, open for editing
                                editPeripheral(item.peripheral.id);
                            } else if (!this.classList.contains('disabled')) {
                                // Check for address conflicts
                                if (hasAddressConflict(item.peripheral)) {
                                    alert(`Cannot select ${item.peripheral.id} because it shares the same address space (${item.peripheral.address}) with another selected peripheral.`);
                                    return;
                                }
                                openPinSelectionModal(item.peripheral, item.category);
                            }
                        });
                        
                        content.appendChild(peripheralItem);
                    });
                    
                    accordionItem.appendChild(header);
                    accordionItem.appendChild(content);
                    accordionContainer.appendChild(accordionItem);
                }
            }
            
            // Set up accordion functionality
            setupAccordionMenu();
        }
        
        // Set up accordion menu functionality
        function setupAccordionMenu() {
            const accordionHeaders = document.querySelectorAll('.accordion-header');
            
            accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const target = this.dataset.target;
                    const content = document.getElementById(target);
                    
                    // Toggle active class on header
                    this.classList.toggle('active');
                    
                    // Toggle content display
                    if (content.classList.contains('active')) {
                        content.classList.remove('active');
                    } else {
                        // Close all other active panels first
                        document.querySelectorAll('.accordion-content.active').forEach(item => {
                            if (item.id !== target) {
                                item.classList.remove('active');
                                const relatedHeader = document.querySelector(`.accordion-header[data-target="${item.id}"]`);
                                if (relatedHeader) {
                                    relatedHeader.classList.remove('active');
                                }
                            }
                        });
                        
                        // Open this panel
                        content.classList.add('active');
                    }
                });
            });
        }
        
        // Handle package selection change
        function handlePackageChange(event) {
            const newPackage = event.target.value;
            
            // Only react if selection actually changed
            if (newPackage !== currentPackage) {
                currentPackage = newPackage;
                
                // Update the chip title display
                document.getElementById('chipTitleDisplay').textContent = `${currentPackage} Pin Layout`;
                
                // In the future, this would redraw the chip based on the selected package
                // For now, we'll just show a message
                if (newPackage === "WLCSP") {
                    alert("WLCSP package support is coming soon!");
                    event.target.value = "QFN-48"; // Reset to QFN-48 for now
                    currentPackage = "QFN-48";
                } else {
                    // Recreate the pin layout for QFN-48
                    createPinLayout();
                    updatePinDisplay();
                }
            }
        }
        
        // Set HF Crystal (XC1/XC2) as system requirement that's always enabled
        function setHFXtalAsSystemRequirement() {
            const pins = ["XC1", "XC2"];
            
            // Assign pins
            usedPins[pins[0]] = {
                peripheral: "32 MHz Crystal",
                function: "XC1",
                required: true,
                isSystem: true
            };
            
            usedPins[pins[1]] = {
                peripheral: "32 MHz Crystal",
                function: "XC2",
                required: true,
                isSystem: true
            };
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Toggle XL1/XL2 pins
        function toggleXL1XL2(event) {
            const pins = ["P1.00", "P1.01"];
            const checked = event.target.checked;
            
            if (checked) {
                // Check if pins are already in use
                if (pins.some(pin => usedPins[pin])) {
                    alert("One or both XL1/XL2 pins (P1.00, P1.01) are already in use.");
                    event.target.checked = false;
                    return;
                }
                
                // Assign pins
                usedPins[pins[0]] = {
                    peripheral: "32.768 kHz Crystal",
                    function: "XL1",
                    required: true
                };
                usedPins[pins[1]] = {
                    peripheral: "32.768 kHz Crystal",
                    function: "XL2",
                    required: true
                };
                
                // Add to selected peripherals
                selectedPeripherals.push({
                    id: "32.768 kHz Crystal",
                    category: "Simple",
                    peripheral: { id: "32.768 kHz Crystal", port: "P1", pins: "P1.00 && P1.01", notes: "Required for low-power operation" },
                    pinFunctions: {
                        "P1.00": "XL1",
                        "P1.01": "XL2"
                    }
                });
            } else {
                // Remove from selected peripherals
                const index = selectedPeripherals.findIndex(p => p.id === "32.768 kHz Crystal");
                if (index !== -1) {
                    selectedPeripherals.splice(index, 1);
                }
                
                // Remove pin assignments
                pins.forEach(pin => {
                    if (usedPins[pin] && usedPins[pin].peripheral === "32.768 kHz Crystal") {
                        delete usedPins[pin];
                    }
                });
            }
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Clear all peripherals
        function clearAllPeripherals(askConfirmation = true) {
            // Confirm with the user if needed
            if (askConfirmation && !confirm('Are you sure you want to clear all peripherals? This action cannot be undone.')) {
                return;
            }
            
            // Clear all selected peripherals except system ones
            selectedPeripherals = selectedPeripherals.filter(p => {
                const isSystem = Object.values(p.pinFunctions).some(func => {
                    const pin = Object.keys(p.pinFunctions).find(pin => p.pinFunctions[pin] === func);
                    return usedPins[pin] && usedPins[pin].isSystem;
                });
                
                // If not keeping this peripheral, free its address space
                if (!isSystem && p.peripheral.address) {
                    delete usedAddresses[p.peripheral.address];
                }
                
                return isSystem;
            });
            
            // Clear all used pins except system ones
            for (const pin in usedPins) {
                if (!usedPins[pin].isSystem) {
                    delete usedPins[pin];
                }
            }
            
            // Reset checkboxes
            document.getElementById('xl1xl2-checkbox').checked = false;
            document.getElementById('nfc-checkbox').checked = false;
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Export configuration
        function exportConfiguration() {
            // Create a configuration object
            const config = {
                package: currentPackage,
                peripherals: selectedPeripherals.map(p => ({
                    id: p.id,
                    category: p.category,
                    pinAssignments: p.pinFunctions,
                    peripheral: p.peripheral
                })),
                pinAssignments: Object.keys(usedPins).map(pin => ({
                    pin: pin,
                    peripheral: usedPins[pin].peripheral,
                    function: usedPins[pin].function,
                    required: usedPins[pin].required,
                    isSystem: usedPins[pin].isSystem || false
                })),
                usedAddresses: Object.keys(usedAddresses).reduce((obj, key) => {
                    obj[key] = usedAddresses[key];
                    return obj;
                }, {})
            };
            
            // Convert to JSON
            const jsonConfig = JSON.stringify(config, null, 2);
            
            // Create a blob and download link
            const blob = new Blob([jsonConfig], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `nrf-pin-config-${currentPackage.toLowerCase()}.json`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Open import modal
        function openImportModal() {
            document.getElementById('importModal').style.display = 'block';
            document.getElementById('importJsonInput').value = '';
            document.getElementById('importFileInput').value = '';
            document.getElementById('importError').style.display = 'none';
            
            // Reset to file upload tab by default
            document.querySelectorAll('.import-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.import-tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('.import-tab-btn[data-tab="file-upload"]').classList.add('active');
            document.getElementById('file-upload').classList.add('active');
        }
        
        // Close import modal
        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
        }
        
        // Import configuration
        function importConfiguration() {
            const errorElement = document.getElementById('importError');
            let jsonInput = '';
            
            // Check which tab is active
            const isFileUploadActive = document.getElementById('file-upload').classList.contains('active');
            
            if (isFileUploadActive) {
                const fileInput = document.getElementById('importFileInput');
                if (!fileInput.files || fileInput.files.length === 0) {
                    errorElement.textContent = 'Please select a JSON file to import.';
                    errorElement.style.display = 'block';
                    return;
                }
                
                // We'll read the file and then process it
                const reader = new FileReader();
                reader.onload = function(e) {
                    processImportedJson(e.target.result);
                };
                reader.onerror = function() {
                    errorElement.textContent = 'Error reading the file. Please try again.';
                    errorElement.style.display = 'block';
                };
                reader.readAsText(fileInput.files[0]);
                return; // Exit here as the file reading is asynchronous
            } else {
                // Get JSON from textarea
                jsonInput = document.getElementById('importJsonInput').value.trim();
                if (!jsonInput) {
                    errorElement.textContent = 'Please paste a JSON configuration.';
                    errorElement.style.display = 'block';
                    return;
                }
                
                // Process the pasted JSON
                processImportedJson(jsonInput);
            }
        }
        
        // Process the imported JSON configuration
        function processImportedJson(jsonInput) {
            const errorElement = document.getElementById('importError');
            
            try {
                // Parse the JSON
                const config = JSON.parse(jsonInput);
                
                // Validate the configuration
                if (!config.package || !config.peripherals || !config.pinAssignments) {
                    throw new Error('Invalid configuration format. Missing required fields.');
                }
                
                // Confirm with the user
                if (!confirm('This will replace your current configuration. Continue?')) {
                    return;
                }
                
                // Clear current configuration
                clearAllPeripherals(false); // Don't ask for confirmation
                
                // Set the package
                if (config.package && document.querySelector(`#packageSelector option[value="${config.package}"]`)) {
                    document.getElementById('packageSelector').value = config.package;
                    currentPackage = config.package;
                    document.getElementById('chipTitleDisplay').textContent = `${currentPackage} Pin Layout`;
                }
                
                // Restore used addresses
                if (config.usedAddresses) {
                    for (const [address, peripheral] of Object.entries(config.usedAddresses)) {
                        usedAddresses[address] = peripheral;
                    }
                }
                
                // Restore pin assignments
                config.pinAssignments.forEach(assignment => {
                    usedPins[assignment.pin] = {
                        peripheral: assignment.peripheral,
                        function: assignment.function,
                        required: assignment.required,
                        isSystem: assignment.isSystem || false
                    };
                });
                
                // Restore peripherals
                config.peripherals.forEach(p => {
                    // Find the peripheral data in our peripherals object
                    let peripheralData = null;
                    let category = p.category;
                    
                    // For simple peripherals like XL1/XL2 and NFC
                    if (p.id === "32.768 kHz Crystal") {
                        document.getElementById('xl1xl2-checkbox').checked = true;
                    } else if (p.id === "NFC Antenna") {
                        document.getElementById('nfc-checkbox').checked = true;
                    } else {
                        // For regular peripherals, find the data
                        for (const cat in peripherals) {
                            const found = peripherals[cat].find(item => item.id === p.id);
                            if (found) {
                                peripheralData = found;
                                category = cat;
                                break;
                            }
                        }
                        
                        // If we found the peripheral data, add it to selected peripherals
                        if (peripheralData) {
                            selectedPeripherals.push({
                                id: p.id,
                                category: category,
                                peripheral: p.peripheral || peripheralData,
                                pinFunctions: p.pinAssignments
                            });
                        }
                    }
                });
                
                // Update UI
                updateSelectedPeripheralsList();
                updatePinDisplay();
                
                // Close the modal
                closeImportModal();
                
                // Show success message
                alert('Configuration imported successfully!');
                
            } catch (error) {
                // Show error message
                errorElement.textContent = `Error importing configuration: ${error.message}`;
                errorElement.style.display = 'block';
                console.error('Import error:', error);
            }
        }
        
        // Toggle NFC pins
        function toggleNFC(event) {
            const pins = ["P1.02", "P1.03"];
            const checked = event.target.checked;
            
            if (checked) {
                // Check if pins are already in use
                if (pins.some(pin => usedPins[pin])) {
                    alert("One or both NFC pins (P1.02, P1.03) are already in use.");
                    event.target.checked = false;
                    return;
                }
                
                // Assign pins
                usedPins[pins[0]] = {
                    peripheral: "NFC Antenna",
                    function: "NFC1",
                    required: true
                };
                usedPins[pins[1]] = {
                    peripheral: "NFC Antenna",
                    function: "NFC2",
                    required: true
                };
                
                // Add to selected peripherals
                selectedPeripherals.push({
                    id: "NFC Antenna",
                    category: "Simple",
                    peripheral: { id: "NFC Antenna", port: "P1", pins: "P1.02 && P1.03", notes: "Required for NFC functionality" },
                    pinFunctions: {
                        "P1.02": "NFC1",
                        "P1.03": "NFC2"
                    }
                });
            } else {
                // Remove from selected peripherals
                const index = selectedPeripherals.findIndex(p => p.id === "NFC Antenna");
                if (index !== -1) {
                    selectedPeripherals.splice(index, 1);
                }
                
                // Remove pin assignments
                pins.forEach(pin => {
                    if (usedPins[pin] && usedPins[pin].peripheral === "NFC Antenna") {
                        delete usedPins[pin];
                    }
                });
            }
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
        }
        
        // Create pin layout for the chip
        function createPinLayout() {
            const chipContainer = document.querySelector('.chip-container');
            
            // Clear existing content
            chipContainer.innerHTML = '';
            
            // Create the chip body
            const chipBody = document.createElement('div');
            chipBody.className = 'chip-body';
            chipContainer.appendChild(chipBody);
            
            // Calculate positions
            const chipSize = 420;
            const pinSize = 20;
            const pinSpacing = (400 - 2 * pinSize) / 11; // 12 pins per side
            const offset = 20; // offset from edge for chip body
            
            // Create all 48 pins
            for (let i = 1; i <= 48; i++) {
                const pinData = getPinDataByNumber(i);
                const pin = document.createElement('div');
                pin.className = 'pin';
                pin.dataset.number = i;
                pin.dataset.name = pinData.name;
                pin.textContent = i;
                
                // Add special classes based on pin type
                if (pinData.type === 'vdd' || pinData.type === 'vss' || pinData.type === 'debug') {
                    pin.classList.add(pinData.type);
                } else if (pinData.isClock) {
                    pin.classList.add('clock');
                }
                
                // Special handling for XC1/XC2 crystal pins
                if (pinData.name === "XC1" || pinData.name === "XC2") {
                    pin.classList.add('system');
                }
                
                // Position the pin based on its number
                if (i <= 12) {
                    // Left side pins (1-12)
                    pin.style.left = '0px';
                    pin.style.top = (pinSize + (i-1) * pinSpacing) + 'px';
                    pin.style.transform = 'translateX(-50%)';
                } else if (i <= 24) {
                    // Bottom side pins (13-24)
                    pin.style.bottom = '0px';
                    pin.style.left = (pinSize + (i-13) * pinSpacing) + 'px';
                    pin.style.transform = 'translateY(50%)';
                } else if (i <= 36) {
                    // Right side pins (25-36)
                    pin.style.right = '0px';
                    pin.style.top = (chipSize - offset - pinSize - (i-25) * pinSpacing) + 'px';
                    pin.style.transform = 'translateX(50%)';
                } else {
                    // Top side pins (37-48)
                    pin.style.top = '0px';
                    pin.style.left = (chipSize - offset - pinSize - (i-37) * pinSpacing) + 'px';
                    pin.style.transform = 'translateY(-50%)';
                }
                
                // Add click event to show pin details
                pin.addEventListener('click', function() {
                    showPinDetails(pinData);
                });
                
                // Add mouseover event to highlight the peripheral using this pin
                pin.addEventListener('mouseover', function() {
                    if (usedPins[pinData.name]) {
                        highlightPeripheralByPin(pinData.name);
                    }
                });
                
                // Add mouseout event to remove highlights
                pin.addEventListener('mouseout', function() {
                    removeAllPeripheralHighlights();
                });
                
                chipContainer.appendChild(pin);
            }
        }
        
        // Get pin data by pin number
        function getPinDataByNumber(number) {
            return pinData.find(pin => pin.number === number) || { name: 'Unknown', type: 'unknown' };
        }
        
        // Get pin data by pin name
        function getPinDataByName(name) {
            return pinData.find(pin => pin.name === name) || null;
        }
        
        // Show pin details in the details panel
        function showPinDetails(pin) {
            const detailsElement = document.getElementById('pinDetails');
            
            let usedBy = '';
            if (usedPins[pin.name]) {
                const usage = usedPins[pin.name];
                const systemBadge = usage.isSystem ? '<span class="system-peripheral">[System]</span> ' : '';
                usedBy = `<p><strong>Used by:</strong> ${systemBadge}${usage.peripheral} (${usage.function})</p>`;
            }
            
            let functionsHtml = '';
            if (pin.functions && pin.functions.length > 0) {
                functionsHtml = `
                    <p><strong>Functions:</strong></p>
                    <ul>
                        ${pin.functions.map(func => `<li>${func}</li>`).join('')}
                    </ul>
                `;
            }
            
            detailsElement.innerHTML = `
                <h3>${pin.name} (Pin ${pin.number})</h3>
                <p><strong>Type:</strong> ${pin.type.toUpperCase()}</p>
                ${pin.isClock ? '<p><strong>Clock capable</strong></p>' : ''}
                ${usedBy}
                ${functionsHtml}
            `;
        }
        
        // Edit an existing peripheral
        function editPeripheral(peripheralId) {
            // Find the peripheral in the selected list
            const peripheralIndex = selectedPeripherals.findIndex(p => p.id === peripheralId);
            if (peripheralIndex === -1) return;
            
            const selectedPeripheral = selectedPeripherals[peripheralIndex];
            
            // Store original configuration to revert if needed
            const originalPinConfig = { ...selectedPeripheral.pinFunctions };
            const originalCategory = selectedPeripheral.category;
            
            // Find the peripheral data
            let peripheralData = null;
            let category = originalCategory;
            
            // Search for the peripheral in all categories
            for (const cat in peripherals) {
                const found = peripherals[cat].find(p => p.id === peripheralId);
                if (found) {
                    peripheralData = found;
                    category = cat;
                    break;
                }
            }
            
            if (!peripheralData) {
                console.error(`Could not find peripheral data for ${peripheralId}`);
                return;
            }
            
            // Special case for simple peripherals that can't be edited
            if (peripheralId === "32.768 kHz Crystal" || peripheralId === "NFC Antenna") {
                alert(`${peripheralId} uses fixed pins and cannot be edited.`);
                return;
            }
            
            // Store current editing state
            currentPeripheral = peripheralData;
            currentCategory = category;
            tempSelectedPins = { ...originalPinConfig };
            
            // Set modal title to indicate editing
            document.getElementById('modalTitle').textContent = `Edit Pins for ${peripheralId}`;
            
            // Get the functions for this peripheral type
            let functionsToUse = getPeripheralFunctions(category, peripheralData);
            
            // First, remove current pin assignments temporarily
            for (const pinName in originalPinConfig) {
                delete usedPins[pinName];
            }
            
            // Populate the pin selection table
            populatePinSelectionTable(functionsToUse, peripheralData);
            
            // Pre-select pins according to existing configuration
            preSelectPins(originalPinConfig, functionsToUse);
            
            // Show the modal
            document.getElementById('pinSelectionModal').style.display = 'block';
            
            // Add event handlers for cancel/confirm that handle editing
            document.getElementById('cancelPinSelection').onclick = function() {
                // Restore original pin configuration
                for (const [pinName, funcName] of Object.entries(originalPinConfig)) {
                    usedPins[pinName] = {
                        peripheral: peripheralId,
                        function: funcName,
                        required: isRequiredFunction(category, funcName)
                    };
                }
                
                closePinSelectionModal();
            };
            
            document.getElementById('confirmPinSelection').onclick = function() {
                const result = updatePeripheralPins(peripheralIndex, peripheralData, category);
                if (result) {
                    closePinSelectionModal();
                }
            };
        }
        
        // Pre-select pins in the modal based on existing configuration
        function preSelectPins(pinConfig, functions) {
            // Handle GPIOTE case specially
            if (currentPeripheral.id.includes('GPIOTE')) {
                // For GPIOTE, we need to associate pins with channel numbers
                // Extract channel numbers from function names in pinConfig
                for (const [pinName, funcName] of Object.entries(pinConfig)) {
                    // Function name format: "GPIOTE PIN-0", "GPIOTE PIN-1", etc.
                    const channelMatch = funcName.match(/GPIOTE PIN-(\d+)/);
                    if (channelMatch) {
                        const channelNum = parseInt(channelMatch[1]);
                        const selectId = `select-gpiote-pin-${channelNum}`;
                        const select = document.getElementById(selectId);
                        
                        if (select) {
                            select.value = pinName;
                        }
                    }
                }
                
                return;
            }
            if (currentPeripheral.id === "TAMPC") {
                // For each shield pair, check if both pins are assigned
                functions.forEach(func => {
                    if (pinConfig[func.outputPin] && pinConfig[func.inputPin]) {
                        const checkbox = document.getElementById(`checkbox-${func.name.replace(/\s+/g, '-')}`);
                        if (checkbox) checkbox.checked = true;
                    }
                });
                return;
            }
            
            // Handle SAADC case specially
            if (currentPeripheral.id === "SAADC") {
                // Check all AIN checkboxes that are assigned
                for (const pinName in pinConfig) {
                    const funcName = pinConfig[pinName];
                    const checkbox = document.getElementById(`checkbox-${funcName}`);
                    if (checkbox) checkbox.checked = true;
                }
                return;
            }
            
            // For regular peripherals with dropdowns
            for (const pinName in pinConfig) {
                const funcName = pinConfig[pinName];
                
                // Find if there is a dropdown for this function
                const selectId = `select-${funcName.replace(/\s+/g, '-').toLowerCase()}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    select.value = pinName;
                }
                
                // Also handle checkboxes for single-option functions
                const checkboxId = `checkbox-${funcName}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = true;
                }
            }
        }
        
        // Update an existing peripheral with new pin assignments
        function updatePeripheralPins(peripheralIndex, peripheral, category) {
            // Check for pin conflicts with other peripherals
            const conflictingPins = [];
            for (const pinName of Object.keys(tempSelectedPins)) {
                if (usedPins[pinName]) {
                    conflictingPins.push(`${pinName} (used by ${usedPins[pinName].peripheral})`);
                }
            }
            
            if (conflictingPins.length > 0) {
                alert(`Cannot assign pins due to conflicts:\n${conflictingPins.join('\n')}`);
                return false;
            }
            
            // Check if the pin selection is valid for peripherals with P2 restrictions
            if (hasP2PinRestrictions(peripheral)) {
                if (!isValidPinSelectionForP2Peripheral(peripheral, tempSelectedPins)) {
                    // Determine the specific error message
                    const usingP1Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P1.'));
                    const usingP2Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P2.'));
                    
                    if (usingP1Pins && usingP2Pins) {
                        alert(`Cannot mix P1 and P2 pins for ${peripheral.id}. You must use either all P1 pins or the specific P2 pins.`);
                    } else if (usingP2Pins) {
                        alert(`Invalid P2 pin selection for ${peripheral.id}. You must use the specific P2 pins designated for this peripheral.`);
                    } else {
                        alert(`Invalid pin selection for ${peripheral.id}.`);
                    }
                    return false;
                }
            }
            
            // Update the peripheral's pin functions
            selectedPeripherals[peripheralIndex].pinFunctions = { ...tempSelectedPins };
            
            // Assign the selected pins
            for (const [pinName, funcName] of Object.entries(tempSelectedPins)) {
                usedPins[pinName] = {
                    peripheral: peripheral.id,
                    function: funcName,
                    required: isRequiredFunction(category, funcName)
                };
            }
            
            // Update the UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
            
            return true;
        }
        
        // Open the pin selection modal for a peripheral
        function openPinSelectionModal(peripheral, category) {
            // Set the current peripheral and category
            currentPeripheral = peripheral;
            currentCategory = category;
            
            // Set the modal title
            document.getElementById('modalTitle').textContent = `Select Pins for ${peripheral.id}`;
            
            // Show warning for peripherals with P2 pin restrictions
            const warningElement = document.getElementById('pinRestrictionWarning');
            if (hasP2PinRestrictions(peripheral)) {
                warningElement.style.display = 'block';
            } else {
                warningElement.style.display = 'none';
            }
            
            // Get the functions for this peripheral type
            let functionsToUse = getPeripheralFunctions(category, peripheral);
            
            // Populate the pin selection table
            populatePinSelectionTable(functionsToUse, peripheral);
            
            // Show the modal
            document.getElementById('pinSelectionModal').style.display = 'block';
        }
        
        // Confirm pin selection
        function confirmPinSelection() {
            // Check if all required functions have pins assigned
            if (currentPeripheral && currentCategory) {
                const functions = getPeripheralFunctions(currentCategory, currentPeripheral);
                const requiredFunctions = functions.filter(f => f.required);
                
                // For GPIOTE, there are no required functions
                if (currentPeripheral.id.includes('GPIOTE')) {
                    // Just check if at least one pin is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one pin for the GPIOTE peripheral.');
                        return;
                    }
                } 
                // For TAMPC, no specific requirements
                else if (currentPeripheral.id === 'TAMPC') {
                    // Just check if at least one shield pair is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one shield pair for the TAMPC peripheral.');
                        return;
                    }
                }
                // For SAADC, no specific requirements
                else if (currentPeripheral.id === 'SAADC') {
                    // Just check if at least one analog input is selected
                    if (Object.keys(tempSelectedPins).length === 0) {
                        alert('Please select at least one analog input for the SAADC peripheral.');
                        return;
                    }
                }
                // For other peripherals, check required functions
                else {
                    for (const func of requiredFunctions) {
                        // Check if this function has a pin assigned
                        const hasPin = Object.values(tempSelectedPins).includes(func.name);
                        if (!hasPin) {
                            alert(`Please select a pin for the required function: ${func.name}`);
                            return;
                        }
                    }
                }
                
                // Check for pin conflicts with other peripherals
                const conflictingPins = [];
                for (const pinName of Object.keys(tempSelectedPins)) {
                    if (usedPins[pinName] && 
                        (!currentPeripheral || usedPins[pinName].peripheral !== currentPeripheral.id)) {
                        conflictingPins.push(`${pinName} (used by ${usedPins[pinName].peripheral})`);
                    }
                }
                
                if (conflictingPins.length > 0) {
                    alert(`Cannot assign pins due to conflicts:\n${conflictingPins.join('\n')}`);
                    return;
                }
                
                // Check if the pin selection is valid for peripherals with P2 restrictions
                if (hasP2PinRestrictions(currentPeripheral)) {
                    if (!isValidPinSelectionForP2Peripheral(currentPeripheral, tempSelectedPins)) {
                        // Determine the specific error message
                        const usingP1Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P1.'));
                        const usingP2Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P2.'));
                        
                        if (usingP1Pins && usingP2Pins) {
                            alert(`Cannot mix P1 and P2 pins for ${currentPeripheral.id}. You must use either all P1 pins or the specific P2 pins.`);
                        } else if (usingP2Pins) {
                            alert(`Invalid P2 pin selection for ${currentPeripheral.id}. You must use the specific P2 pins designated for this peripheral.`);
                        } else {
                            alert(`Invalid pin selection for ${currentPeripheral.id}.`);
                        }
                        return;
                    }
                }
                
                // All checks passed, add the peripheral
                const peripheralConfig = {
                    id: currentPeripheral.id,
                    category: currentCategory,
                    peripheral: currentPeripheral,
                    pinFunctions: { ...tempSelectedPins }
                };
                
                // Register the address space as used
                if (currentPeripheral.address) {
                    usedAddresses[currentPeripheral.address] = currentPeripheral.id;
                }
                
                // Check if this peripheral is already in the list (for editing)
                const existingIndex = selectedPeripherals.findIndex(p => p.id === currentPeripheral.id);
                if (existingIndex !== -1) {
                    // Remove old pin assignments
                    const oldPinFunctions = selectedPeripherals[existingIndex].pinFunctions;
                    for (const pinName in oldPinFunctions) {
                        delete usedPins[pinName];
                    }
                    
                    // Update the peripheral
                    selectedPeripherals[existingIndex] = peripheralConfig;
                } else {
                    // Add new peripheral
                    selectedPeripherals.push(peripheralConfig);
                }
                
                // Assign the selected pins
                for (const [pinName, funcName] of Object.entries(tempSelectedPins)) {
                    usedPins[pinName] = {
                        peripheral: currentPeripheral.id,
                        function: funcName,
                        required: isRequiredFunction(currentCategory, funcName)
                    };
                }
                
                // Update the UI
                updateSelectedPeripheralsList();
                updatePinDisplay();
                
                // Close the modal
                closePinSelectionModal();
            }
        }
        
        // Close the pin selection modal
        function closePinSelectionModal() {
            document.getElementById('pinSelectionModal').style.display = 'none';
            
            // Reset handlers to default
            document.getElementById('cancelPinSelection').onclick = function() {
                closePinSelectionModal();
            };
            
            document.getElementById('confirmPinSelection').onclick = confirmPinSelection;
            
            currentPeripheral = null;
            currentCategory = null;
            tempSelectedPins = {};
        }
        
        // Check if a function has only one possible pin option
        function hasOnlyOneOption(func, allowedPorts) {
            // If it has a specific pin, it definitely has only one option
            if (func.specificPin) {
                return true;
            }
            
            // Count the number of pins that match the requirements
            let count = 0;
            for (const pin of pinData) {
                // Must be an I/O pin
                if (pin.type !== 'io') continue;
                
                // Must be in an allowed port
                if (!allowedPorts.includes(pin.port)) continue;
                
                // If clock is required, the pin must support it
                if (func.requiresClock && !pin.isClock) continue;
                
                // Pin must not be already used by another peripheral
                if (usedPins[pin.name]) continue;
                
                count++;
                if (count > 1) return false; // More than one option
            }
            
            return count === 1; // True if exactly one option
        }
        
        // Get the ports that a peripheral can use
        function getPortsForPeripheral(peripheral) {
            const portStr = peripheral.port;
            if (portStr === "Mixed") {
                return ["P0", "P1", "P2"];
            }
            
            const ports = [];
            if (portStr.includes("Port 0")) ports.push("P0");
            if (portStr.includes("Port 1")) ports.push("P1");
            if (portStr.includes("Port 2")) ports.push("P2");
            
            return ports;
        }
        
        // Populate select options with compatible pins
        function populatePinSelectOptions(select, func, allowedPorts) {
            // If there's a specific pin required for this function
            if (func.specificPin) {
                const pin = getPinDataByName(func.specificPin);
                if (pin) {
                    const option = new Option(`${pin.name} (Pin ${pin.number})`, pin.name);
                    select.add(option);
                    if (func.required) {
                        select.value = pin.name;
                        select.disabled = true;
                    }
                }
                return;
            }
            
            // Check if we're dealing with a peripheral that has P2 pin restrictions
            const hasP2Restrictions = hasP2PinRestrictions(currentPeripheral);
            
            // Check if we've already selected any pins for this peripheral
            const usingP1Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P1.'));
            const usingP2Pins = Object.keys(tempSelectedPins).some(pin => pin.startsWith('P2.'));
            
            // Get the restricted P2 pins for this function if applicable
            const restrictedP2Pins = hasP2Restrictions ? getRestrictedP2Pins(currentPeripheral) : {};
            
            // Get all available pins that match the requirements
            const availablePins = pinData.filter(pin => {
                // Must be an I/O pin
                if (pin.type !== 'io') return false;
                
                // Must be in an allowed port
                if (!allowedPorts.includes(pin.port)) return false;
                
                // If clock is required, the pin must support it
                if (func.requiresClock && !pin.isClock) return false;
                
                // Pin must not be already used by another peripheral
                if (usedPins[pin.name]) return false;
                
                // Pin must not be temporarily selected for another function in the current dialog
                if (tempSelectedPins[pin.name] && tempSelectedPins[pin.name] !== func.name) return false;
                
                // For peripherals with P2 restrictions:
                if (hasP2Restrictions) {
                    // Special case for SPIM/SPIS00 - only allow its dedicated P2 pins
                    if (currentPeripheral.id === "SPIM/SPIS00") {
                        if (!pin.name.startsWith('P2.')) {
                            return false;
                        }
                        
                        // Only allow pins in the restricted list with the correct function
                        const allowedFunction = restrictedP2Pins[pin.name];
                        if (!allowedFunction || !func.name.includes(allowedFunction)) {
                            return false;
                        }
                    } else {
                        // For other peripherals with P2 restrictions:
                        // If we're already using P1 pins, don't allow P2 pins
                        if (usingP1Pins && pin.name.startsWith('P2.')) {
                            return false;
                        }
                        
                        // If we're already using P2 pins, don't allow P1 pins
                        if (usingP2Pins && pin.name.startsWith('P1.')) {
                            return false;
                        }
                        
                        // If this is a P2 pin, check if it's in the restricted list for this function
                        if (pin.name.startsWith('P2.')) {
                            // Check if this P2 pin is allowed for this function
                            const allowedFunction = restrictedP2Pins[pin.name];
                            if (!allowedFunction || !func.name.includes(allowedFunction)) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            });
            
            // Add options for each available pin
            availablePins.forEach(pin => {
                const option = new Option(`${pin.name} (Pin ${pin.number})${pin.isClock ? ' - Clock' : ''}`, pin.name);
                select.add(option);
            });
            
            // If no pins are available, add a disabled option
            if (availablePins.length === 0) {
                const option = new Option('No compatible pins available', '');
                option.disabled = true;
                select.add(option);
            }
        }
        
        // Populate the pin selection table with functions and available pins
        function populatePinSelectionTable(functions, peripheral) {
            const tableBody = document.getElementById('pinSelectionTableBody');
            tableBody.innerHTML = '';
            
            // Get the ports this peripheral can use
            const ports = getPortsForPeripheral(peripheral);
            
            // Initialize tempSelectedPins
            tempSelectedPins = {};
            
            // Check if this is GPIOTE - special case for channel handling
            if (peripheral.id.includes('GPIOTE')) {
                // Create header row explaining GPIOTE channels
                const headerRow = document.createElement('tr');
                const maxChannels = peripheral.id === "GPIOTE20" ? 8 : 4;
                
                headerRow.innerHTML = `
                    <td colspan="4" style="background-color: #f0f0f0; text-align: center;">
                        <strong>${peripheral.id} - ${maxChannels} Channels</strong><br>
                        Each channel can be assigned to one pin. Select which pins to use for each channel.
                    </td>
                `;
                tableBody.appendChild(headerRow);
                
                // Create a filtered list of ports for this GPIOTE instance
                let filteredPorts = [...ports];
                if (peripheral.id === "GPIOTE20") {
                    // Only P1 pins for GPIOTE20
                    filteredPorts = ["P1"];
                } else if (peripheral.id === "GPIOTE30") {
                    // Only P0 pins for GPIOTE30
                    filteredPorts = ["P0"];
                }
                
                // Get the correct function list based on the peripheral ID
                const gpioteFunctions = peripheral.id === "GPIOTE20" ? 
                                        peripheralFunctions.GPIOTE20 : 
                                        peripheralFunctions.GPIOTE30;
                
                // Add each channel as a separate row with pin selection
                gpioteFunctions.forEach(func => {
                    const row = document.createElement('tr');
                    
                    // Create cells for function name and required status
                    const funcNameCell = document.createElement('td');
                    funcNameCell.textContent = func.name;
                    
                    const requiredCell = document.createElement('td');
                    requiredCell.textContent = func.required ? 'Yes' : 'No';
                    
                    const selectionCell = document.createElement('td');
                    
                    // Create dropdown for pin selection
                    const select = document.createElement('select');
                    select.id = `select-gpiote-pin-${func.channel}`;
                    select.dataset.function = func.name;
                    select.dataset.channel = func.channel;
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- Select Pin --';
                    select.appendChild(defaultOption);
                    
                    // Add change event listener
                    select.addEventListener('change', function() {
                        const selectedPin = this.value;
                        const functionName = this.dataset.function;
                        
                        // If a pin was previously selected for this function, remove it from tempSelectedPins
                        Object.keys(tempSelectedPins).forEach(pin => {
                            if (tempSelectedPins[pin] === functionName) {
                                delete tempSelectedPins[pin];
                            }
                        });
                        
                        // If a new pin is selected, add it to tempSelectedPins
                        if (selectedPin) {
                            tempSelectedPins[selectedPin] = functionName;
                        }
                        
                        // Update all GPIOTE dropdowns to reflect the new selection
                        updateGpioteDropdowns(gpioteFunctions, filteredPorts);
                    });
                    
                    selectionCell.appendChild(select);
                    
                    // We'll populate all GPIOTE dropdowns at once after all are created
                    
                    const notesCell = document.createElement('td');
                    notesCell.textContent = `Channel ${func.channel} - can be assigned to one pin`;
                    
                    row.appendChild(funcNameCell);
                    row.appendChild(requiredCell);
                    row.appendChild(selectionCell);
                    row.appendChild(notesCell);
                    
                    tableBody.appendChild(row);
                });
                
                // Populate all GPIOTE dropdowns at once
                updateGpioteDropdowns(gpioteFunctions, filteredPorts);
                
                return; // Skip the standard function handling
            }
            
            // Check if this is TAMPC - special case for paired pins
            if (peripheral.id === "TAMPC") {
                // Create header row explaining the pin pairs
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <td colspan="4" style="background-color: #f0f0f0; text-align: center;">
                        <strong>TAMPC Active Shield Pairs</strong><br>
                        Each shield consists of an output (ASO) and input (ASI) pin pair that must be used together
                    </td>
                `;
                tableBody.appendChild(headerRow);
                
                // Add each shield pair as a row with a checkbox
                functions.forEach(func => {
                    const row = document.createElement('tr');
                    
                    // Create cells for function name and required status
                    const funcNameCell = document.createElement('td');
                    funcNameCell.textContent = func.name;
                    
                    const requiredCell = document.createElement('td');
                    requiredCell.textContent = 'No';
                    
                    const selectionCell = document.createElement('td');
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'checkbox-option';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `checkbox-${func.name.replace(/\s+/g, '-')}`;
                    
                    // Check if either pin in the pair is already used
                    const isOutputUsed = !!usedPins[func.outputPin];
                    const isInputUsed = !!usedPins[func.inputPin];
                    
                    if (isOutputUsed || isInputUsed) {
                        checkbox.disabled = true;
                    }
                    
                    // Add change event to handle the paired pins
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            // Add both pins of the pair
                            tempSelectedPins[func.outputPin] = func.outputFunc;
                            tempSelectedPins[func.inputPin] = func.inputFunc;
                        } else {
                            // Remove both pins of the pair
                            delete tempSelectedPins[func.outputPin];
                            delete tempSelectedPins[func.inputPin];
                        }
                    });
                    
                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.innerHTML = `
                        ${func.outputPin} (${func.outputFunc}) and ${func.inputPin} (${func.inputFunc})
                    `;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    selectionCell.appendChild(checkboxDiv);
                    
                    const notesCell = document.createElement('td');
                    notesCell.textContent = `Both pins must be used together`;
                    
                    row.appendChild(funcNameCell);
                    row.appendChild(requiredCell);
                    row.appendChild(selectionCell);
                    row.appendChild(notesCell);
                    
                    tableBody.appendChild(row);
                });
                
                return; // Skip the standard function handling
            }
            
            // Check if this is SAADC - special case for checkbox selection
            const isSAADC = peripheral.id === "SAADC";
            
            // For each function, create a row with either checkboxes or dropdown
            functions.forEach(func => {
                const row = document.createElement('tr');
                
                // Create cells for function name and required status
                const funcNameCell = document.createElement('td');
                funcNameCell.textContent = func.name;
                
                const requiredCell = document.createElement('td');
                requiredCell.textContent = func.required ? 'Yes' : 'No';
                
                const selectionCell = document.createElement('td');
                const notesCell = document.createElement('td');
                notesCell.textContent = func.requiresClock ? 'Requires clock pin' : '';
                
                // Add cells to row
                row.appendChild(funcNameCell);
                row.appendChild(requiredCell);
                row.appendChild(selectionCell);
                row.appendChild(notesCell);
                
                // Special case for SAADC or if the function has only one pin option - use checkboxes
                if (isSAADC || hasOnlyOneOption(func, ports)) {
                    // Create a div for the checkbox options
                    const checkboxOptions = document.createElement('div');
                    checkboxOptions.className = 'checkbox-options';
                    
                    // If specific pin is defined or only one pin is available
                    if (func.specificPin) {
                        // Add a single checkbox for the specific pin
                        const pin = getPinDataByName(func.specificPin);
                        
                        if (pin) {
                            const checkboxOption = document.createElement('div');
                            checkboxOption.className = 'checkbox-option';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `checkbox-${func.name}`;
                            checkbox.value = pin.name;
                            checkbox.dataset.function = func.name;
                            
                            // Check if pin is already used
                            const isPinUsed = !!usedPins[pin.name];
                            if (isPinUsed) {
                                checkbox.disabled = true;
                            }
                            
                            // Add change event
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    tempSelectedPins[this.value] = this.dataset.function;
                                } else {
                                    delete tempSelectedPins[this.value];
                                }
                            });
                            
                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = `${pin.name} (Pin ${pin.number})`;
                            
                            checkboxOption.appendChild(checkbox);
                            checkboxOption.appendChild(label);
                            checkboxOptions.appendChild(checkboxOption);
                        }
                    } else {
                        // Find the only available pin
                        const availablePins = pinData.filter(pin => {
                            // Must be an I/O pin
                            if (pin.type !== 'io') return false;
                            
                            // Must be in an allowed port
                            if (!ports.includes(pin.port)) return false;
                            
                            // If clock is required, the pin must support it
                            if (func.requiresClock && !pin.isClock) return false;
                            
                            // Pin must not be already used by another peripheral
                            if (usedPins[pin.name]) return false;
                            
                            return true;
                        });
                        
                        if (availablePins.length === 1) {
                            const pin = availablePins[0];
                            const checkboxOption = document.createElement('div');
                            checkboxOption.className = 'checkbox-option';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `checkbox-${func.name}`;
                            checkbox.value = pin.name;
                            checkbox.dataset.function = func.name;
                            
                            // If function is required, check by default
                            if (func.required) {
                                checkbox.checked = true;
                                tempSelectedPins[pin.name] = func.name;
                            }
                            
                            // Add change event
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    tempSelectedPins[this.value] = this.dataset.function;
                                } else {
                                    delete tempSelectedPins[this.value];
                                }
                            });
                            
                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = `${pin.name} (Pin ${pin.number})`;
                            
                            checkboxOption.appendChild(checkbox);
                            checkboxOption.appendChild(label);
                            checkboxOptions.appendChild(checkboxOption);
                        }
                    }
                    
                    selectionCell.appendChild(checkboxOptions);
                } else {
                    // Regular dropdown selection for multiple options
                    const select = document.createElement('select');
                    select.id = `select-${func.name.replace(/\s+/g, '-').toLowerCase()}`;
                    select.dataset.function = func.name;
                    if (func.required) {
                        select.required = true;
                    }
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- Select Pin --';
                    select.appendChild(defaultOption);
                    
                    // Add change event listener
                    select.addEventListener('change', function() {
                        const selectedPin = this.value;
                        const functionName = this.dataset.function;
                        
                        // If a pin was previously selected for this function, remove it from tempSelectedPins
                        Object.keys(tempSelectedPins).forEach(pin => {
                            if (tempSelectedPins[pin] === functionName) {
                                delete tempSelectedPins[pin];
                            }
                        });
                        
                        // If a new pin is selected, add it to tempSelectedPins
                        if (selectedPin) {
                            tempSelectedPins[selectedPin] = functionName;
                            
                            // Check if we should auto-select P2 pins
                            if (shouldAutoSelectP2Pins(currentPeripheral, selectedPin)) {
                                // Ask the user if they want to auto-select the P2 pins
                                if (confirm(`You've selected a P2 pin for ${currentPeripheral.id}. Would you like to automatically select the designated P2 pins for all functions?`)) {
                                    autoSelectP2Pins(currentPeripheral);
                                    return; // Skip the normal update since autoSelectP2Pins will handle it
                                }
                            }
                        }
                        
                        // Update all dropdowns to reflect the new selection
                        updateAllPinDropdowns(functions, ports);
                    });
                    
                    selectionCell.appendChild(select);
                    
                    // Populate the select with compatible pins
                    populatePinSelectOptions(select, func, ports);
                }
                
                tableBody.appendChild(row);
            });
        }
        
        // Update all pin dropdowns in the modal
        function updateAllPinDropdowns(functions, ports) {
            functions.forEach(func => {
                const selectId = `select-${func.name.replace(/\s+/g, '-').toLowerCase()}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    // Save the current selection
                    const currentValue = select.value;
                    
                    // Clear and repopulate options
                    select.innerHTML = '<option value="">-- Select Pin --</option>';
                    populatePinSelectOptions(select, func, ports);
                    
                    // Restore the selection if it's still valid
                    if (currentValue && (select.querySelector(`option[value="${currentValue}"]`))) {
                        select.value = currentValue;
                    }
                }
            });
        }
        
        // Helper function to check if a peripheral with P2 restrictions should auto-select P2 pins
        function shouldAutoSelectP2Pins(peripheral, pinName) {
            // If this peripheral doesn't have P2 restrictions, no auto-selection
            if (!hasP2PinRestrictions(peripheral)) {
                return false;
            }
            
            // Don't suggest auto-selection for SPIM/SPIS00 as it has fixed pins
            if (peripheral.id === "SPIM/SPIS00") {
                return false;
            }
            
            // If we already have some P2 pins selected, don't suggest again
            const hasOtherP2Pins = Object.keys(tempSelectedPins).some(pin => 
                pin !== pinName && pin.startsWith('P2.')
            );
            
            if (hasOtherP2Pins) {
                return false;
            }
            
            // If the selected pin is a P2 pin, suggest auto-selecting the rest of the P2 pins
            // Also check if we're in the middle of an auto-selection to prevent multiple popups
            return pinName.startsWith('P2.') && !window.isAutoSelectingP2Pins;
        }
        
        // Helper function to auto-select P2 pins for a peripheral with P2 restrictions
        function autoSelectP2Pins(peripheral) {
            // Set a flag to prevent multiple popups during auto-selection
            window.isAutoSelectingP2Pins = true;
            
            // Get the restricted P2 pins for this peripheral
            const restrictedPins = getRestrictedP2Pins(peripheral);
            
            // For each function in the pin selection table
            const tableBody = document.getElementById('pinSelectionTableBody');
            const rows = tableBody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const funcNameCell = row.querySelector('td:first-child');
                if (!funcNameCell) return;
                
                const funcName = funcNameCell.textContent;
                const select = row.querySelector('select');
                
                if (select) {
                    // Find the matching P2 pin for this function
                    for (const [pin, func] of Object.entries(restrictedPins)) {
                        if (funcName.includes(func)) {
                            // Find the option with this pin value
                            const option = select.querySelector(`option[value="${pin}"]`);
                            if (option) {
                                // Select this pin
                                select.value = pin;
                                
                                // Trigger the change event
                                const event = new Event('change');
                                select.dispatchEvent(event);
                                
                                break;
                            }
                        }
                    }
                }
            });
            
            // Reset the flag after auto-selection is complete
            setTimeout(() => {
                window.isAutoSelectingP2Pins = false;
            }, 100);
        }
        
        // Update GPIOTE pin dropdowns to filter out pins already selected in the same peripheral
        function updateGpioteDropdowns(functions, ports) {
            functions.forEach(func => {
                const selectId = `select-gpiote-pin-${func.channel}`;
                const select = document.getElementById(selectId);
                
                if (select) {
                    // Save the current selection
                    const currentValue = select.value;
                    
                    // Clear and repopulate options
                    select.innerHTML = '<option value="">-- Select Pin --</option>';
                    
                    // Get all available pins that match the requirements
                    const availablePins = pinData.filter(pin => {
                        // Must be an I/O pin
                        if (pin.type !== 'io') return false;
                        
                        // Must be in an allowed port
                        if (!ports.includes(pin.port)) return false;
                        
                        // Pin must not be already used by another peripheral
                        if (usedPins[pin.name]) return false;
                        
                        // Pin must not be temporarily selected for another GPIOTE function in the current dialog
                        const isAlreadySelectedForGpiote = Object.entries(tempSelectedPins).some(([pinName, funcName]) => {
                            return pinName === pin.name && funcName !== func.name && funcName.includes('GPIOTE PIN');
                        });
                        
                        if (isAlreadySelectedForGpiote) return false;
                        
                        return true;
                    });
                    
                    // Add options for each available pin
                    availablePins.forEach(pin => {
                        const option = new Option(`${pin.name} (Pin ${pin.number})${pin.isClock ? ' - Clock' : ''}`, pin.name);
                        select.add(option);
                    });
                    
                    // If no pins are available, add a disabled option
                    if (availablePins.length === 0) {
                        const option = new Option('No compatible pins available', '');
                        option.disabled = true;
                        select.add(option);
                    }
                    
                    // Restore the selection if it's still valid
                    if (currentValue && (select.querySelector(`option[value="${currentValue}"]`))) {
                        select.value = currentValue;
                    }
                }
            });
        }
        
        // Update the selected peripherals list
        function updateSelectedPeripheralsList() {
            const selectedList = document.getElementById('selectedList');
            selectedList.innerHTML = '';
            
            if (selectedPeripherals.length === 0) {
                const emptyMessage = document.createElement('li');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'No peripherals selected yet.';
                selectedList.appendChild(emptyMessage);
                return;
            }
            
            // Add each peripheral to the list
            selectedPeripherals.forEach(peripheral => {
                const item = document.createElement('li');
                item.className = 'selected-item';
                
                // Check if this is a system peripheral
                const isSystem = Object.values(peripheral.pinFunctions).some(func => {
                    const pin = Object.keys(peripheral.pinFunctions).find(pin => peripheral.pinFunctions[pin] === func);
                    return usedPins[pin] && usedPins[pin].isSystem;
                });
                
                if (isSystem) {
                    item.classList.add('system');
                }
                
                // Create the item content
                const pinList = Object.entries(peripheral.pinFunctions)
                    .map(([pin, func]) => `${pin}: ${func}`)
                    .join(', ');
                
                item.innerHTML = `
                    <div>
                        <strong>${peripheral.id}</strong>
                        <div>${pinList}</div>
                        <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                            <i>Click to edit pin assignments</i>
                        </div>
                    </div>
                    <button class="remove-btn ${isSystem ? 'disabled' : ''}" 
                            data-id="${peripheral.id}" 
                            ${isSystem ? 'disabled' : ''}>
                        Remove
                    </button>
                `;
                
                // Add event listener to the remove button
                const removeBtn = item.querySelector('.remove-btn');
                if (!isSystem) {
                    removeBtn.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent triggering the parent click
                        removePeripheral(peripheral.id);
                    });
                }
                
                // Make the entire item clickable to edit the peripheral
                item.addEventListener('click', function() {
                    editPeripheral(peripheral.id);
                });
                
                // Add mouseover event to highlight pins used by this peripheral
                item.addEventListener('mouseover', function() {
                    highlightPeripheralPins(peripheral.pinFunctions);
                });
                
                // Add mouseout event to remove highlights
                item.addEventListener('mouseout', function() {
                    removeAllPinHighlights();
                });
                
                selectedList.appendChild(item);
            });
        }
        
        // Remove a peripheral
        function removePeripheral(peripheralId) {
            // Find the peripheral
            const index = selectedPeripherals.findIndex(p => p.id === peripheralId);
            if (index === -1) return;
            
            const peripheral = selectedPeripherals[index];
            
            // Remove pin assignments
            for (const pinName in peripheral.pinFunctions) {
                delete usedPins[pinName];
            }
            
            // Remove from selected peripherals
            selectedPeripherals.splice(index, 1);
            
            // Free up the address space
            if (peripheral.peripheral.address) {
                delete usedAddresses[peripheral.peripheral.address];
            }
            
            // Update UI
            updateSelectedPeripheralsList();
            updatePinDisplay();
            
            // Update checkboxes for special peripherals
            if (peripheralId === "32.768 kHz Crystal") {
                document.getElementById('xl1xl2-checkbox').checked = false;
            } else if (peripheralId === "NFC Antenna") {
                document.getElementById('nfc-checkbox').checked = false;
            }
        }
        
        // Update the pin display
        function updatePinDisplay() {
            // Update all pins
            document.querySelectorAll('.pin').forEach(pinElement => {
                const pinName = pinElement.dataset.name;
                
                // Reset classes
                pinElement.classList.remove('used', 'required', 'system');
                
                // Add appropriate classes based on pin usage
                if (usedPins[pinName]) {
                    pinElement.classList.add('used');
                    
                    if (usedPins[pinName].required) {
                        pinElement.classList.add('required');
                    }
                    
                    if (usedPins[pinName].isSystem) {
                        pinElement.classList.add('system');
                    }
                }
            });
            
            // Update peripheral UI based on address conflicts
            updatePeripheralUIForAddressConflicts();
        }
        
        // Highlight pins used by a peripheral
        function highlightPeripheralPins(pinFunctions) {
            // Remove any existing highlights first
            removeAllPinHighlights();
            
            // Add highlight class to each pin used by this peripheral
            for (const pinName in pinFunctions) {
                const pinElements = document.querySelectorAll(`.pin[data-name="${pinName}"]`);
                pinElements.forEach(pin => {
                    pin.classList.add('highlighted');
                });
            }
        }
        
        // Remove all pin highlights
        function removeAllPinHighlights() {
            document.querySelectorAll('.pin.highlighted').forEach(pin => {
                pin.classList.remove('highlighted');
            });
        }
        
        // Update peripheral UI to disable items with address conflicts
        function updatePeripheralUIForAddressConflicts() {
            // Update single-instance peripherals
            document.querySelectorAll('#single-peripherals-container .single-peripheral-btn').forEach(btn => {
                const peripheralId = btn.dataset.id;
                const category = btn.dataset.category;
                
                // Find the peripheral data
                const peripheralData = peripherals[category]?.find(p => p.id === peripheralId);
                if (!peripheralData) return;
                
                // Check if this peripheral is already selected
                const isSelected = btn.classList.contains('selected');
                
                // If not selected, check for address conflicts
                if (!isSelected) {
                    const hasConflict = hasAddressConflict(peripheralData);
                    
                    // Update UI based on conflict status
                    if (hasConflict) {
                        btn.classList.add('disabled');
                        btn.title = `Cannot select: shares address space ${peripheralData.address} with ${usedAddresses[peripheralData.address]}`;
                    } else {
                        btn.classList.remove('disabled');
                        btn.title = '';
                    }
                }
            });
            
            // Update multi-instance peripherals
            document.querySelectorAll('.peripheral-item').forEach(item => {
                const peripheralId = item.dataset.id;
                const category = item.dataset.category;
                
                // Find the peripheral data
                const peripheralData = peripherals[category]?.find(p => p.id === peripheralId);
                if (!peripheralData) return;
                
                // Check if this peripheral is already selected
                const isSelected = item.classList.contains('selected');
                
                // If not selected, check for address conflicts
                if (!isSelected) {
                    const hasConflict = hasAddressConflict(peripheralData);
                    
                    // Update UI based on conflict status
                    if (hasConflict) {
                        item.classList.add('disabled');
                        item.title = `Cannot select: shares address space ${peripheralData.address} with ${usedAddresses[peripheralData.address]}`;
                    } else {
                        item.classList.remove('disabled');
                        item.title = '';
                    }
                }
            });
        }
        
        // Highlight the peripheral that uses a specific pin
        function highlightPeripheralByPin(pinName) {
            // Remove any existing highlights first
            removeAllPeripheralHighlights();
            
            // If the pin is used by a peripheral, highlight that peripheral in the list
            if (usedPins[pinName]) {
                const peripheralId = usedPins[pinName].peripheral;
                const peripheralItems = document.querySelectorAll(`.selected-item`);
                
                peripheralItems.forEach(item => {
                    // Check if this item represents the peripheral we're looking for
                    const itemTitle = item.querySelector('strong').textContent;
                    if (itemTitle === peripheralId) {
                        item.classList.add('highlighted');
                    }
                });
            }
        }
        
        // Remove all peripheral highlights
        function removeAllPeripheralHighlights() {
            document.querySelectorAll('.selected-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
        }
        
        // Filter peripherals based on search input
        function filterPeripherals() {
            const searchText = document.getElementById('searchPeripherals').value.toLowerCase();
            
            // Filter single-instance peripherals
            const singlePeripheralButtons = document.querySelectorAll('#single-peripherals-container .single-peripheral-btn');
            singlePeripheralButtons.forEach(button => {
                const peripheralText = button.textContent.toLowerCase();
                if (peripheralText.includes(searchText)) {
                    button.style.display = 'block';
                } else {
                    button.style.display = 'none';
                }
            });
            
            // Filter multi-instance peripherals in accordion
            const accordionItems = document.querySelectorAll('.accordion-item');
            accordionItems.forEach(item => {
                const header = item.querySelector('.accordion-header');
                const content = item.querySelector('.accordion-content');
                const headerText = header.textContent.toLowerCase();
                
                // Check if header matches
                const headerMatches = headerText.includes(searchText);
                
                // Check if any peripheral items in this category match
                const peripheralItems = item.querySelectorAll('.peripheral-item');
                let anyItemMatches = false;
                
                peripheralItems.forEach(pItem => {
                    const pItemText = pItem.textContent.toLowerCase();
                    if (pItemText.includes(searchText)) {
                        pItem.style.display = 'flex';
                        anyItemMatches = true;
                    } else {
                        pItem.style.display = 'none';
                    }
                });
                
                // Show/hide the entire accordion item based on matches
                if (headerMatches || anyItemMatches) {
                    item.style.display = 'block';
                    if (searchText && anyItemMatches) {
                        // Auto-expand accordion if search matches items inside
                        header.classList.add('active');
                        content.classList.add('active');
                    }
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show a message if no results
            const singleContainer = document.getElementById('single-peripherals-container');
            const accordionContainer = document.getElementById('peripheralAccordion');
            
            const noSingleResults = Array.from(singlePeripheralButtons).every(btn => btn.style.display === 'none');
            const noAccordionResults = Array.from(accordionItems).every(item => item.style.display === 'none');
            
            // If search is not empty and no results found, show message
            if (searchText && noSingleResults && noAccordionResults) {
                // Check if message already exists
                let noResultsMsg = document.getElementById('no-results-message');
                if (!noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.id = 'no-results-message';
                    noResultsMsg.style.padding = '10px';
                    noResultsMsg.style.color = '#666';
                    noResultsMsg.style.fontStyle = 'italic';
                    noResultsMsg.style.textAlign = 'center';
                    accordionContainer.parentNode.insertBefore(noResultsMsg, accordionContainer);
                }
                noResultsMsg.textContent = `No peripherals found matching "${searchText}"`;
                noResultsMsg.style.display = 'block';
            } else {
                // Hide message if it exists
                const noResultsMsg = document.getElementById('no-results-message');
                if (noResultsMsg) {
                    noResultsMsg.style.display = 'none';
                }
            }
        }
		</script>
	</body>
</html>
